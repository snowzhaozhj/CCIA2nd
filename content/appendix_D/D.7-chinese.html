<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>D.7 thread头文件 - C++ConcurrencyInAction</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../content/Praise_for_the_first_edition.html"><strong aria-hidden="true">1.</strong> 第一版的赞许</a></li><li class="chapter-item expanded "><a href="../../content/preface-chinese.html"><strong aria-hidden="true">2.</strong> 前言</a></li><li class="chapter-item expanded "><a href="../../content/acknowledgments-chinese.html"><strong aria-hidden="true">3.</strong> 感谢</a></li><li class="chapter-item expanded "><a href="../../content/about_this_book-chinese.html"><strong aria-hidden="true">4.</strong> 关于本书</a></li><li class="chapter-item expanded "><a href="../../content/about_the_author-chinese.html"><strong aria-hidden="true">5.</strong> 关于作者</a></li><li class="chapter-item expanded "><a href="../../content/about_cover_illustration-chinese.html"><strong aria-hidden="true">6.</strong> 关于封面</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.0-chinese.html"><strong aria-hidden="true">7.</strong> 第1章 你好，并发世界</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter1/1.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 1.1 何谓并发</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 1.2 为什么使用并发</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.3-chinese.html"><strong aria-hidden="true">7.3.</strong> 1.3 并发和多线程</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.4-chinese.html"><strong aria-hidden="true">7.4.</strong> 1.4 开始入门</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.5-chinese.html"><strong aria-hidden="true">7.5.</strong> 1.5 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.0-chinese.html"><strong aria-hidden="true">8.</strong> 第2章 线程管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter2/2.1-chinese.html"><strong aria-hidden="true">8.1.</strong> 2.1 线程的基本操作</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 2.2 传递参数</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.3-chinese.html"><strong aria-hidden="true">8.3.</strong> 2.3 转移所有权</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 2.4 确定线程数量</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.5-chinese.html"><strong aria-hidden="true">8.5.</strong> 2.5 线程标识</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.6-chinese.html"><strong aria-hidden="true">8.6.</strong> 2.6 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.0-chinese.html"><strong aria-hidden="true">9.</strong> 第3章 共享数据</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter3/3.1-chinese.html"><strong aria-hidden="true">9.1.</strong> 3.1 共享数据的问题</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.2-chinese.html"><strong aria-hidden="true">9.2.</strong> 3.2 使用互斥量</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.3-chinese.html"><strong aria-hidden="true">9.3.</strong> 3.3 保护共享数据的方式</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.4-chinese.html"><strong aria-hidden="true">9.4.</strong> 3.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.0-chinese.html"><strong aria-hidden="true">10.</strong> 第4章 同步操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter4/4.1-chinese.html"><strong aria-hidden="true">10.1.</strong> 4.1 等待事件或条件</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.2-chinese.html"><strong aria-hidden="true">10.2.</strong> 4.2 使用future</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.3-chinese.html"><strong aria-hidden="true">10.3.</strong> 4.3 限时等待</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.4-chinese.html"><strong aria-hidden="true">10.4.</strong> 4.4 简化代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.5-chinese.html"><strong aria-hidden="true">10.5.</strong> 4.5 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.0-chinese.html"><strong aria-hidden="true">11.</strong> 第5章 内存模型和原子操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter5/5.1-chinese.html"><strong aria-hidden="true">11.1.</strong> 5.1 内存模型</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.2-chinese.html"><strong aria-hidden="true">11.2.</strong> 5.2 原子操作和原子类型</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.3-chinese.html"><strong aria-hidden="true">11.3.</strong> 5.3 同步操作和强制排序</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.4-chinese.html"><strong aria-hidden="true">11.4.</strong> 5.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.0-chinese.html"><strong aria-hidden="true">12.</strong> 第6章 设计基于锁的并发数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter6/6.1-chinese.html"><strong aria-hidden="true">12.1.</strong> 6.1 并发设计的意义</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.2-chinese.html"><strong aria-hidden="true">12.2.</strong> 6.2 基于锁的并发数据结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.3-chinese.html"><strong aria-hidden="true">12.3.</strong> 6.3 设计更加复杂的数据结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.4-chinese.html"><strong aria-hidden="true">12.4.</strong> 6.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.0-chinese.html"><strong aria-hidden="true">13.</strong> 第7章 设计无锁的并发数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter7/7.1-chinese.html"><strong aria-hidden="true">13.1.</strong> 7.1 定义和意义</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.2-chinese.html"><strong aria-hidden="true">13.2.</strong> 7.2 无锁数据结构的例子</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.3-chinese.html"><strong aria-hidden="true">13.3.</strong> 7.3 设计无锁数据结构的指导建议</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.4-chinese.html"><strong aria-hidden="true">13.4.</strong> 7.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.0-chinese.html"><strong aria-hidden="true">14.</strong> 第8章 并发设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter8/8.1-chinese.html"><strong aria-hidden="true">14.1.</strong> 8.1 线程间划分工作</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.2-chinese.html"><strong aria-hidden="true">14.2.</strong> 8.2 并发代码的性能</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.3-chinese.html"><strong aria-hidden="true">14.3.</strong> 8.3 为多线程性能设计数据结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.4-chinese.html"><strong aria-hidden="true">14.4.</strong> 8.4 设计并发代码的注意事项</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.5-chinese.html"><strong aria-hidden="true">14.5.</strong> 8.5 在实践中设计并发代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.6-chinese.html"><strong aria-hidden="true">14.6.</strong> 8.6 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.0-chinese.html"><strong aria-hidden="true">15.</strong> 第9章 高级线程管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter9/9.1-chinese.html"><strong aria-hidden="true">15.1.</strong> 9.1 线程池</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.2-chinese.html"><strong aria-hidden="true">15.2.</strong> 9.2 中断线程</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.3-chinese.html"><strong aria-hidden="true">15.3.</strong> 9.3 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.0-chinese.html"><strong aria-hidden="true">16.</strong> 第10章 并行算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter10/10.1-chinese.html"><strong aria-hidden="true">16.1.</strong> 10.1 并行化标准库算法</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.2-chinese.html"><strong aria-hidden="true">16.2.</strong> 10.2 执行策略</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.3-chinese.html"><strong aria-hidden="true">16.3.</strong> 10.3 C++标准库中的并行算法</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.4-chinese.html"><strong aria-hidden="true">16.4.</strong> 10.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.0-chinese.html"><strong aria-hidden="true">17.</strong> 第11章 测试和调试多线程应用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter11/11.1-chinese.html"><strong aria-hidden="true">17.1.</strong> 11.1 与并发相关的Bug</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.2-chinese.html"><strong aria-hidden="true">17.2.</strong> 11.2 定位并发Bug的技巧</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.3-chinese.html"><strong aria-hidden="true">17.3.</strong> 11.3 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.0-chinese.html"><strong aria-hidden="true">18.</strong> 附录A C++11特性简明参考(部分)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/appendix_A/A.1-chinese.html"><strong aria-hidden="true">18.1.</strong> A.1 右值引用</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.2-chinese.html"><strong aria-hidden="true">18.2.</strong> A.2 删除函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.3-chinese.html"><strong aria-hidden="true">18.3.</strong> A.3 默认函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.4-chinese.html"><strong aria-hidden="true">18.4.</strong> A.4 常量表达式函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.5-chinese.html"><strong aria-hidden="true">18.5.</strong> A.5 Lambda函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.6-chinese.html"><strong aria-hidden="true">18.6.</strong> A.6 变参模板</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.7-chinese.html"><strong aria-hidden="true">18.7.</strong> A.7 自动推导变量类型</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.8-chinese.html"><strong aria-hidden="true">18.8.</strong> A.8 线程本地变量</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.9-chinese.html"><strong aria-hidden="true">18.9.</strong> A.9 模板类参数的推导</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.10-chinese.html"><strong aria-hidden="true">18.10.</strong> A.10 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/appendix_B/B.0-chinese.html"><strong aria-hidden="true">19.</strong> 附录B 并发库简要对比</a></li><li class="chapter-item expanded "><a href="../../content/appendix_C/C.0-chinese.html"><strong aria-hidden="true">20.</strong> 附录C 消息传递框架与完整的ATM示例</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.0-chinese.html"><strong aria-hidden="true">21.</strong> 附录D C++线程类库参考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/appendix_D/D.1-chinese.html"><strong aria-hidden="true">21.1.</strong> D.1 chrono头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.2-chinese.html"><strong aria-hidden="true">21.2.</strong> D.2 condition_variable头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.3-chinese.html"><strong aria-hidden="true">21.3.</strong> D.3 atomic头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.4-chinese.html"><strong aria-hidden="true">21.4.</strong> D.4 future头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.5-chinese.html"><strong aria-hidden="true">21.5.</strong> D.5 mutex头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.6-chinese.html"><strong aria-hidden="true">21.6.</strong> D.6 ratio头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.7-chinese.html" class="active"><strong aria-hidden="true">21.7.</strong> D.7 thread头文件</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">C++ConcurrencyInAction</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="d7-thread头文件"><a class="header" href="#d7-thread头文件">D.7 &lt;thread&gt;头文件</a></h1>
<p><code>&lt;thread&gt;</code>头文件提供了管理和辨别线程的工具，并且提供函数，可让当前线程休眠。</p>
<p><strong>头文件内容</strong></p>
<pre><code>namespace std
{
  class thread;

  namespace this_thread
  {
    thread::id get_id() noexcept;

    void yield() noexcept;

    template&lt;typename Rep,typename Period&gt;
    void sleep_for(
        std::chrono::duration&lt;Rep,Period&gt; sleep_duration);

    template&lt;typename Clock,typename Duration&gt;
    void sleep_until(
        std::chrono::time_point&lt;Clock,Duration&gt; wake_time);
  }
}
</code></pre>
<h2 id="d71-stdthread类"><a class="header" href="#d71-stdthread类">D.7.1 std::thread类</a></h2>
<p><code>std::thread</code>用来管理线程的执行。其提供让新的线程执行或执行，也提供对线程的识别，以及提供其他函数用于管理线程的执行。</p>
<pre><code>class thread
{
public:
  // Types
  class id;
  typedef implementation-defined native_handle_type; // optional

  // Construction and Destruction
  thread() noexcept;
  ~thread();

  template&lt;typename Callable,typename Args...&gt;
  explicit thread(Callable&amp;&amp; func,Args&amp;&amp;... args);

  // Copying and Moving
  thread(thread const&amp; other) = delete;
  thread(thread&amp;&amp; other) noexcept;

  thread&amp; operator=(thread const&amp; other) = delete;
  thread&amp; operator=(thread&amp;&amp; other) noexcept;

  void swap(thread&amp; other) noexcept;

  void join();
  void detach();
  bool joinable() const noexcept;

  id get_id() const noexcept;
  native_handle_type native_handle();
  static unsigned hardware_concurrency() noexcept;
};

void swap(thread&amp; lhs,thread&amp; rhs);
</code></pre>
<h3 id="stdthreadid-类"><a class="header" href="#stdthreadid-类">std::thread::id 类</a></h3>
<p>可以通过<code>std::thread::id</code>实例对执行线程进行识别。</p>
<p><strong>类型定义</strong></p>
<pre><code>class thread::id
{
public:
  id() noexcept;
};

bool operator==(thread::id x, thread::id y) noexcept;
bool operator!=(thread::id x, thread::id y) noexcept;
bool operator&lt;(thread::id x, thread::id y) noexcept;
bool operator&lt;=(thread::id x, thread::id y) noexcept;
bool operator&gt;(thread::id x, thread::id y) noexcept;
bool operator&gt;=(thread::id x, thread::id y) noexcept;

template&lt;typename charT, typename traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, thread::id id);
</code></pre>
<p><strong>Notes</strong>
<code>std::thread::id</code>的值可以识别不同的执行，每个<code>std::thread::id</code>默认构造出来的值都不一样，不同值代表不同的执行线程。</p>
<p><code>std::thread::id</code>的值是不可预测的，在同一程序中的不同线程的id也不同。</p>
<p><code>std::thread::id</code>是可以CopyConstructible(拷贝构造)和CopyAssignable(拷贝赋值)，所以对于<code>std::thread::id</code>的拷贝和赋值是没有限制的。</p>
<h4 id="stdthreadid-默认构造函数"><a class="header" href="#stdthreadid-默认构造函数">std::thread::id 默认构造函数</a></h4>
<p>构造一个<code>std::thread::id</code>对象，其不能表示任何执行线程。</p>
<p><strong>声明</strong></p>
<pre><code>id() noexcept;
</code></pre>
<p><strong>效果</strong>
构造一个<code>std::thread::id</code>实例，不能表示任何一个线程值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong> 所有默认构造的<code>std::thread::id</code>实例存储的同一个值。</p>
<h4 id="stdthreadid-相等比较操作"><a class="header" href="#stdthreadid-相等比较操作">std::thread::id 相等比较操作</a></h4>
<p>比较两个<code>std::thread::id</code>的值，看是两个执行线程是否相等。</p>
<p><strong>声明</strong></p>
<pre><code>bool operator==(std::thread::id lhs,std::thread::id rhs) noexcept;
</code></pre>
<p><strong>返回</strong>
当lhs和rhs表示同一个执行线程或两者不代表没有任何线程，则返回true。当lsh和rhs表示不同执行线程或其中一个代表一个执行线程，另一个不代表任何线程，则返回false。</p>
<p><strong>抛出</strong>
无</p>
<h4 id="stdthreadid-不相等比较操作"><a class="header" href="#stdthreadid-不相等比较操作">std::thread::id 不相等比较操作</a></h4>
<p>比较两个<code>std::thread::id</code>的值，看是两个执行线程是否相等。</p>
<p><strong>声明</strong></p>
<pre><code>bool operator！=(std::thread::id lhs,std::thread::id rhs) noexcept;
</code></pre>
<p><strong>返回</strong>
<code>!(lhs==rhs)</code></p>
<p><strong>抛出</strong>
无</p>
<h4 id="stdthreadid-小于比较操作"><a class="header" href="#stdthreadid-小于比较操作">std::thread::id 小于比较操作</a></h4>
<p>比较两个<code>std::thread::id</code>的值，看是两个执行线程哪个先执行。</p>
<p><strong>声明</strong></p>
<pre><code>bool operator&lt;(std::thread::id lhs,std::thread::id rhs) noexcept;
</code></pre>
<p><strong>返回</strong>
当lhs比rhs的线程ID靠前，则返回true。当lhs!=rhs，且<code>lhs&lt;rhs</code>或<code>rhs&lt;lhs</code>返回true，其他情况则返回false。当lhs==rhs，在<code>lhs&lt;rhs</code>和<code>rhs&lt;lhs</code>时返回false。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong> 当默认构造的<code>std::thread::id</code>实例，在不代表任何线程的时候，其值小于任何一个代表执行线程的实例。当两个实例相等，那么两个对象代表两个执行线程。任何一组不同的<code>std::thread::id</code>的值，是由同一序列构造，这与程序执行的顺序相同。同一个可执行程序可能有不同的执行顺序。</p>
<h4 id="stdthreadid-小于等于比较操作"><a class="header" href="#stdthreadid-小于等于比较操作">std::thread::id 小于等于比较操作</a></h4>
<p>比较两个<code>std::thread::id</code>的值，看是两个执行线程的ID值是否相等，或其中一个先行。</p>
<p><strong>声明</strong></p>
<pre><code>bool operator&lt;(std::thread::id lhs,std::thread::id rhs) noexcept;
</code></pre>
<p><strong>返回</strong>
<code>!(rhs&lt;lhs)</code></p>
<p><strong>抛出</strong>
无</p>
<h4 id="stdthreadid-大于比较操作"><a class="header" href="#stdthreadid-大于比较操作">std::thread::id 大于比较操作</a></h4>
<p>比较两个<code>std::thread::id</code>的值，看是两个执行线程的是后行的。</p>
<p><strong>声明</strong></p>
<pre><code>bool operator&gt;(std::thread::id lhs,std::thread::id rhs) noexcept;
</code></pre>
<p><strong>返回</strong>
<code>rhs&lt;lhs</code></p>
<p><strong>抛出</strong>
无</p>
<h4 id="stdthreadid-大于等于比较操作"><a class="header" href="#stdthreadid-大于等于比较操作">std::thread::id 大于等于比较操作</a></h4>
<p>比较两个<code>std::thread::id</code>的值，看是两个执行线程的ID值是否相等，或其中一个后行。</p>
<p><strong>声明</strong></p>
<pre><code>bool operator&gt;=(std::thread::id lhs,std::thread::id rhs) noexcept;
</code></pre>
<p><strong>返回</strong>
<code>!(lhs&lt;rhs)</code></p>
<p><strong>抛出</strong>
无</p>
<h4 id="stdthreadid-插入流操作"><a class="header" href="#stdthreadid-插入流操作">std::thread::id 插入流操作</a></h4>
<p>将<code>std::thread::id</code>的值通过给指定流写入字符串。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename charT, typename traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, thread::id id);
</code></pre>
<p><strong>效果</strong>
将<code>std::thread::id</code>的值通过给指定流插入字符串。</p>
<p><strong>返回</strong>
无</p>
<p><strong>NOTE</strong> 字符串的格式并未给定。<code>std::thread::id</code>实例具有相同的表达式时，是相同的；当实例表达式不同，则代表不同的线程。</p>
<h3 id="stdthreadnative_handler-成员函数"><a class="header" href="#stdthreadnative_handler-成员函数">std::thread::native_handler 成员函数</a></h3>
<p><code>native_handle_type</code>是由另一类型定义而来，这个类型会随着指定平台的API而变化。</p>
<p><strong>声明</strong></p>
<pre><code>typedef implementation-defined native_handle_type;
</code></pre>
<p><strong>NOTE</strong> 这个类型定义是可选的。如果提供，实现将使用原生平台指定的API，并提供合适的类型作为实现。</p>
<h3 id="stdthread-默认构造函数"><a class="header" href="#stdthread-默认构造函数">std::thread 默认构造函数</a></h3>
<p>返回一个<code>native_handle_type</code>类型的值，这个值可以可以表示*this相关的执行线程。</p>
<p><strong>声明</strong></p>
<pre><code>native_handle_type native_handle();
</code></pre>
<p><strong>NOTE</strong> 这个函数是可选的。如果提供，会使用原生平台指定的API，并返回合适的值。</p>
<h3 id="stdthread-构造函数"><a class="header" href="#stdthread-构造函数">std::thread 构造函数</a></h3>
<p>构造一个无相关线程的<code>std::thread</code>对象。</p>
<p><strong>声明</strong></p>
<pre><code>thread() noexcept;
</code></pre>
<p><strong>效果</strong>
构造一个无相关线程的<code>std::thread</code>实例。</p>
<p><strong>后置条件</strong>
对于一个新构造的<code>std::thread</code>对象x，x.get_id() == id()。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdthread-移动构造函数"><a class="header" href="#stdthread-移动构造函数">std::thread 移动构造函数</a></h3>
<p>将已存在<code>std::thread</code>对象的所有权，转移到新创建的对象中。</p>
<p><strong>声明</strong></p>
<pre><code>thread(thread&amp;&amp; other) noexcept;
</code></pre>
<p><strong>效果</strong>
构造一个<code>std::thread</code>实例。与other相关的执行线程的所有权，将转移到新创建的<code>std::thread</code>对象上。否则，新创建的<code>std::thread</code>对象将无任何相关执行线程。</p>
<p><strong>后置条件</strong>
对于一个新构建的<code>std::thread</code>对象x来说，x.get_id()等价于未转移所有权时的other.get_id()。get_id()==id()。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong> <code>std::thread</code>对象是不可CopyConstructible(拷贝构造)，所以该类没有拷贝构造函数，只有移动构造函数。</p>
<h3 id="stdthread-析构函数"><a class="header" href="#stdthread-析构函数">std::thread 析构函数</a></h3>
<p>销毁<code>std::thread</code>对象。</p>
<p><strong>声明</strong></p>
<pre><code>~thread();
</code></pre>
<p><strong>效果</strong>
销毁<code>*this</code>。当<code>*this</code>与执行线程相关(this-&gt;joinable()将返回true)，调用<code>std::terminate()</code>来终止程序。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdthread-移动赋值操作"><a class="header" href="#stdthread-移动赋值操作">std::thread 移动赋值操作</a></h3>
<p>将一个<code>std::thread</code>的所有权，转移到另一个<code>std::thread</code>对象上。</p>
<p><strong>声明</strong></p>
<pre><code>thread&amp; operator=(thread&amp;&amp; other) noexcept;
</code></pre>
<p><strong>效果</strong>
在调用该函数前，this-&gt;joinable返回true，则调用<code>std::terminate()</code>来终止程序。当other在执行赋值前，具有相关的执行线程，那么执行线程现在就与<code>*this</code>相关联。否则，<code>*this</code>无相关执行线程。</p>
<p><strong>后置条件</strong>
this-&gt;get_id()的值等于调用该函数前的other.get_id()。oter.get_id()==id()。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong> <code>std::thread</code>对象是不可CopyAssignable(拷贝赋值)，所以该类没有拷贝赋值函数，只有移动赋值函数。</p>
<h3 id="stdthreadswap-成员函数"><a class="header" href="#stdthreadswap-成员函数">std::thread::swap 成员函数</a></h3>
<p>将两个<code>std::thread</code>对象的所有权进行交换。</p>
<p><strong>声明</strong></p>
<pre><code>void swap(thread&amp; other) noexcept;
</code></pre>
<p><strong>效果</strong>
当other在执行赋值前，具有相关的执行线程，那么执行线程现在就与<code>*this</code>相关联。否则，<code>*this</code>无相关执行线程。对于<code>*this</code>也是一样。</p>
<p><strong>后置条件</strong>
this-&gt;get_id()的值等于调用该函数前的other.get_id()。other.get_id()的值等于没有调用函数前this-&gt;get_id()的值。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdthread的非成员函数swap"><a class="header" href="#stdthread的非成员函数swap">std::thread的非成员函数swap</a></h3>
<p>将两个<code>std::thread</code>对象的所有权进行交换。</p>
<p><strong>声明</strong></p>
<pre><code>void swap(thread&amp; lhs,thread&amp; rhs) noexcept;
</code></pre>
<p><strong>效果</strong>
lhs.swap(rhs)</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdthreadjoinable-成员函数"><a class="header" href="#stdthreadjoinable-成员函数">std::thread::joinable 成员函数</a></h3>
<p>查询*this是否具有相关执行线程。</p>
<p><strong>声明</strong></p>
<pre><code>bool joinable() const noexcept;
</code></pre>
<p><strong>返回</strong>
如果*this具有相关执行线程，则返回true；否则，返回false。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdthreadjoin-成员函数"><a class="header" href="#stdthreadjoin-成员函数">std::thread::join 成员函数</a></h3>
<p>等待*this相关的执行线程结束。</p>
<p><strong>声明</strong></p>
<pre><code>void join();
</code></pre>
<p><strong>先决条件</strong>
this-&gt;joinable()返回true。</p>
<p><strong>效果</strong>
阻塞当前线程，直到与*this相关的执行线程执行结束。</p>
<p><strong>后置条件</strong>
this-&gt;get_id()==id()。与*this先关的执行线程将在该函数调用后结束。</p>
<p><strong>同步</strong>
想要在*this上成功的调用该函数，则需要依赖有joinable()的返回。</p>
<p><strong>抛出</strong>
当效果没有达到或this-&gt;joinable()返回false，则抛出<code>std::system_error</code>异常。</p>
<h3 id="stdthreaddetach-成员函数"><a class="header" href="#stdthreaddetach-成员函数">std::thread::detach 成员函数</a></h3>
<p>将*this上的相关线程进行分离。</p>
<p><strong>声明</strong></p>
<pre><code>void detach();
</code></pre>
<p><strong>先决条件</strong>
this-&gt;joinable()返回true。</p>
<p><strong>效果</strong>
将*this上的相关线程进行分离。</p>
<p><strong>后置条件</strong>
this-&gt;get_id()==id(), this-&gt;joinable()==false</p>
<p>与*this相关的执行线程在调用该函数后就会分离，并且不在会与当前<code>std::thread</code>对象再相关。</p>
<p><strong>抛出</strong>
当效果没有达到或this-&gt;joinable()返回false，则抛出<code>std::system_error</code>异常。</p>
<h3 id="stdthreadget_id-成员函数"><a class="header" href="#stdthreadget_id-成员函数">std::thread::get_id 成员函数</a></h3>
<p>返回<code>std::thread::id</code>的值来表示*this上相关执行线程。</p>
<p><strong>声明</strong></p>
<pre><code>thread::id get_id() const noexcept;
</code></pre>
<p><strong>返回</strong>
当*this具有相关执行线程，将返回<code>std::thread::id</code>作为识别当前函数的依据。否则，返回默认构造的<code>std::thread::id</code>。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdthreadhardware_concurrency-静态成员函数"><a class="header" href="#stdthreadhardware_concurrency-静态成员函数">std::thread::hardware_concurrency 静态成员函数</a></h3>
<p>返回硬件上可以并发线程的数量。</p>
<p><strong>声明</strong></p>
<pre><code>unsigned hardware_concurrency() noexcept;
</code></pre>
<p><strong>返回</strong>
硬件上可以并发线程的数量。这个值可能是系统处理器的数量。当信息不用或只有定义，则该函数返回0。</p>
<p><strong>抛出</strong>
无</p>
<h2 id="d72-this_thread命名空间"><a class="header" href="#d72-this_thread命名空间">D.7.2 this_thread命名空间</a></h2>
<p>这里介绍一下<code>std::this_thread</code>命名空间内提供的函数操作。</p>
<h3 id="this_threadget_id-非成员函数"><a class="header" href="#this_threadget_id-非成员函数">this_thread::get_id 非成员函数</a></h3>
<p>返回<code>std::thread::id</code>用来识别当前执行线程。</p>
<p><strong>声明</strong></p>
<pre><code>thread::id get_id() noexcept;
</code></pre>
<p><strong>返回</strong>
可通过<code>std:thread::id</code>来识别当前线程。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="this_threadyield-非成员函数"><a class="header" href="#this_threadyield-非成员函数">this_thread::yield 非成员函数</a></h3>
<p>该函数用于通知库，调用线程不需要立即运行。一般使用小循环来避免消耗过多CPU时间。</p>
<p><strong>声明</strong></p>
<pre><code>void yield() noexcept;
</code></pre>
<p><strong>效果</strong>
使用标准库的实现来安排线程的一些事情。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="this_threadsleep_for-非成员函数"><a class="header" href="#this_threadsleep_for-非成员函数">this_thread::sleep_for 非成员函数</a></h3>
<p>在指定的指定时长内，暂停执行当前线程。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename Rep,typename Period&gt;
void sleep_for(std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);
</code></pre>
<p><strong>效果</strong>
在超出relative_time的时长内，阻塞当前线程。</p>
<p><strong>NOTE</strong> 线程可能阻塞的时间要长于指定时长。如果可能，逝去的时间由将会由一个稳定时钟决定。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="this_threadsleep_until-非成员函数"><a class="header" href="#this_threadsleep_until-非成员函数">this_thread::sleep_until 非成员函数</a></h3>
<p>暂停指定当前线程，直到到了指定的时间点。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename Clock,typename Duration&gt;
void sleep_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);
</code></pre>
<p><strong>效果</strong>
在到达absolute_time的时间点前，阻塞当前线程，这个时间点由指定的Clock决定。</p>
<p><strong>NOTE</strong> 这里不保证会阻塞多长时间，只有Clock::now()返回的时间等于或大于absolute_time时，阻塞的线程才能被解除阻塞。</p>
<p><strong>抛出</strong>
无</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../content/appendix_D/D.6-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../content/appendix_D/D.6-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
