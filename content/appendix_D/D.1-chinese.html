<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>D.1 chrono头文件 - C++ConcurrencyInAction</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../content/Praise_for_the_first_edition.html"><strong aria-hidden="true">1.</strong> 第一版的赞许</a></li><li class="chapter-item expanded "><a href="../../content/preface-chinese.html"><strong aria-hidden="true">2.</strong> 前言</a></li><li class="chapter-item expanded "><a href="../../content/acknowledgments-chinese.html"><strong aria-hidden="true">3.</strong> 感谢</a></li><li class="chapter-item expanded "><a href="../../content/about_this_book-chinese.html"><strong aria-hidden="true">4.</strong> 关于本书</a></li><li class="chapter-item expanded "><a href="../../content/about_the_author-chinese.html"><strong aria-hidden="true">5.</strong> 关于作者</a></li><li class="chapter-item expanded "><a href="../../content/about_cover_illustration-chinese.html"><strong aria-hidden="true">6.</strong> 关于封面</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.0-chinese.html"><strong aria-hidden="true">7.</strong> 第1章 你好，并发世界</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter1/1.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 1.1 何谓并发</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 1.2 为什么使用并发</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.3-chinese.html"><strong aria-hidden="true">7.3.</strong> 1.3 并发和多线程</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.4-chinese.html"><strong aria-hidden="true">7.4.</strong> 1.4 开始入门</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.5-chinese.html"><strong aria-hidden="true">7.5.</strong> 1.5 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.0-chinese.html"><strong aria-hidden="true">8.</strong> 第2章 线程管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter2/2.1-chinese.html"><strong aria-hidden="true">8.1.</strong> 2.1 线程的基本操作</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 2.2 传递参数</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.3-chinese.html"><strong aria-hidden="true">8.3.</strong> 2.3 转移所有权</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 2.4 确定线程数量</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.5-chinese.html"><strong aria-hidden="true">8.5.</strong> 2.5 线程标识</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.6-chinese.html"><strong aria-hidden="true">8.6.</strong> 2.6 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.0-chinese.html"><strong aria-hidden="true">9.</strong> 第3章 共享数据</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter3/3.1-chinese.html"><strong aria-hidden="true">9.1.</strong> 3.1 共享数据的问题</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.2-chinese.html"><strong aria-hidden="true">9.2.</strong> 3.2 使用互斥量</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.3-chinese.html"><strong aria-hidden="true">9.3.</strong> 3.3 保护共享数据的方式</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.4-chinese.html"><strong aria-hidden="true">9.4.</strong> 3.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.0-chinese.html"><strong aria-hidden="true">10.</strong> 第4章 同步操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter4/4.1-chinese.html"><strong aria-hidden="true">10.1.</strong> 4.1 等待事件或条件</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.2-chinese.html"><strong aria-hidden="true">10.2.</strong> 4.2 使用future</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.3-chinese.html"><strong aria-hidden="true">10.3.</strong> 4.3 限时等待</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.4-chinese.html"><strong aria-hidden="true">10.4.</strong> 4.4 简化代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.5-chinese.html"><strong aria-hidden="true">10.5.</strong> 4.5 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.0-chinese.html"><strong aria-hidden="true">11.</strong> 第5章 内存模型和原子操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter5/5.1-chinese.html"><strong aria-hidden="true">11.1.</strong> 5.1 内存模型</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.2-chinese.html"><strong aria-hidden="true">11.2.</strong> 5.2 原子操作和原子类型</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.3-chinese.html"><strong aria-hidden="true">11.3.</strong> 5.3 同步操作和强制排序</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.4-chinese.html"><strong aria-hidden="true">11.4.</strong> 5.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.0-chinese.html"><strong aria-hidden="true">12.</strong> 第6章 设计基于锁的并发数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter6/6.1-chinese.html"><strong aria-hidden="true">12.1.</strong> 6.1 并发设计的意义</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.2-chinese.html"><strong aria-hidden="true">12.2.</strong> 6.2 基于锁的并发数据结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.3-chinese.html"><strong aria-hidden="true">12.3.</strong> 6.3 设计更加复杂的数据结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.4-chinese.html"><strong aria-hidden="true">12.4.</strong> 6.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.0-chinese.html"><strong aria-hidden="true">13.</strong> 第7章 设计无锁的并发数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter7/7.1-chinese.html"><strong aria-hidden="true">13.1.</strong> 7.1 定义和意义</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.2-chinese.html"><strong aria-hidden="true">13.2.</strong> 7.2 无锁数据结构的例子</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.3-chinese.html"><strong aria-hidden="true">13.3.</strong> 7.3 设计无锁数据结构的指导建议</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.4-chinese.html"><strong aria-hidden="true">13.4.</strong> 7.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.0-chinese.html"><strong aria-hidden="true">14.</strong> 第8章 并发设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter8/8.1-chinese.html"><strong aria-hidden="true">14.1.</strong> 8.1 线程间划分工作</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.2-chinese.html"><strong aria-hidden="true">14.2.</strong> 8.2 并发代码的性能</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.3-chinese.html"><strong aria-hidden="true">14.3.</strong> 8.3 为多线程性能设计数据结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.4-chinese.html"><strong aria-hidden="true">14.4.</strong> 8.4 设计并发代码的注意事项</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.5-chinese.html"><strong aria-hidden="true">14.5.</strong> 8.5 在实践中设计并发代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.6-chinese.html"><strong aria-hidden="true">14.6.</strong> 8.6 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.0-chinese.html"><strong aria-hidden="true">15.</strong> 第9章 高级线程管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter9/9.1-chinese.html"><strong aria-hidden="true">15.1.</strong> 9.1 线程池</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.2-chinese.html"><strong aria-hidden="true">15.2.</strong> 9.2 中断线程</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.3-chinese.html"><strong aria-hidden="true">15.3.</strong> 9.3 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.0-chinese.html"><strong aria-hidden="true">16.</strong> 第10章 并行算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter10/10.1-chinese.html"><strong aria-hidden="true">16.1.</strong> 10.1 并行化标准库算法</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.2-chinese.html"><strong aria-hidden="true">16.2.</strong> 10.2 执行策略</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.3-chinese.html"><strong aria-hidden="true">16.3.</strong> 10.3 C++标准库中的并行算法</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.4-chinese.html"><strong aria-hidden="true">16.4.</strong> 10.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.0-chinese.html"><strong aria-hidden="true">17.</strong> 第11章 测试和调试多线程应用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter11/11.1-chinese.html"><strong aria-hidden="true">17.1.</strong> 11.1 与并发相关的Bug</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.2-chinese.html"><strong aria-hidden="true">17.2.</strong> 11.2 定位并发Bug的技巧</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.3-chinese.html"><strong aria-hidden="true">17.3.</strong> 11.3 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.0-chinese.html"><strong aria-hidden="true">18.</strong> 附录A C++11特性简明参考(部分)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/appendix_A/A.1-chinese.html"><strong aria-hidden="true">18.1.</strong> A.1 右值引用</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.2-chinese.html"><strong aria-hidden="true">18.2.</strong> A.2 删除函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.3-chinese.html"><strong aria-hidden="true">18.3.</strong> A.3 默认函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.4-chinese.html"><strong aria-hidden="true">18.4.</strong> A.4 常量表达式函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.5-chinese.html"><strong aria-hidden="true">18.5.</strong> A.5 Lambda函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.6-chinese.html"><strong aria-hidden="true">18.6.</strong> A.6 变参模板</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.7-chinese.html"><strong aria-hidden="true">18.7.</strong> A.7 自动推导变量类型</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.8-chinese.html"><strong aria-hidden="true">18.8.</strong> A.8 线程本地变量</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.9-chinese.html"><strong aria-hidden="true">18.9.</strong> A.9 模板类参数的推导</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.10-chinese.html"><strong aria-hidden="true">18.10.</strong> A.10 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/appendix_B/B.0-chinese.html"><strong aria-hidden="true">19.</strong> 附录B 并发库简要对比</a></li><li class="chapter-item expanded "><a href="../../content/appendix_C/C.0-chinese.html"><strong aria-hidden="true">20.</strong> 附录C 消息传递框架与完整的ATM示例</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.0-chinese.html"><strong aria-hidden="true">21.</strong> 附录D C++线程类库参考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/appendix_D/D.1-chinese.html" class="active"><strong aria-hidden="true">21.1.</strong> D.1 chrono头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.2-chinese.html"><strong aria-hidden="true">21.2.</strong> D.2 condition_variable头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.3-chinese.html"><strong aria-hidden="true">21.3.</strong> D.3 atomic头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.4-chinese.html"><strong aria-hidden="true">21.4.</strong> D.4 future头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.5-chinese.html"><strong aria-hidden="true">21.5.</strong> D.5 mutex头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.6-chinese.html"><strong aria-hidden="true">21.6.</strong> D.6 ratio头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.7-chinese.html"><strong aria-hidden="true">21.7.</strong> D.7 thread头文件</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">C++ConcurrencyInAction</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="d1-chrono头文件"><a class="header" href="#d1-chrono头文件">D.1 &lt;chrono&gt;头文件</a></h1>
<p>&lt;chrono&gt;头文件作为<code>time_point</code>的提供者，具有代表时间点的类，duration类和时钟类。每个时钟都有一个<code>is_steady</code>静态数据成员，这个成员用来表示该时钟是否是一个<em>稳定的</em>时钟(以匀速计时的时钟，且不可调节)。<code>std::chrono::steady_clock</code>是唯一个能保证稳定的时钟类。</p>
<p>头文件正文</p>
<pre><code class="language-c++">namespace std
{
  namespace chrono
  {
    template&lt;typename Rep,typename Period = ratio&lt;1&gt;&gt;
    class duration;
    template&lt;
        typename Clock,
        typename Duration = typename Clock::duration&gt;
    class time_point;
    class system_clock;
    class steady_clock;
    typedef unspecified-clock-type high_resolution_clock;
  }
}
</code></pre>
<h2 id="d11-stdchronoduration类型模板"><a class="header" href="#d11-stdchronoduration类型模板">D.1.1 std::chrono::duration类型模板</a></h2>
<p><code>std::chrono::duration</code>类模板可以用来表示时间。模板参数<code>Rep</code>和<code>Period</code>是用来存储持续时间的数据类型，<code>std::ratio</code>实例代表了时间的长度(几分之一秒)，其表示了在两次“时钟滴答”后的时间(时钟周期)。因此，<code>std::chrono::duration&lt;int, std::milli&gt;</code>即为，时间以毫秒数的形式存储到int类型中，而<code>std::chrono::duration&lt;short, std::ratio&lt;1,50&gt;&gt;</code>则是记录1/50秒的个数，并将个数存入short类型的变量中，还有<code>std::chrono::duration &lt;long long, std::ratio&lt;60,1&gt;&gt;</code>则是将分钟数存储到long long类型的变量中。</p>
<h3 id="类的定义"><a class="header" href="#类的定义">类的定义</a></h3>
<pre><code class="language-c++">template &lt;class Rep, class Period=ratio&lt;1&gt; &gt;
class duration
{
public:
  typedef Rep rep;
  typedef Period period;

  constexpr duration() = default;
  ~duration() = default;

  duration(const duration&amp;) = default;
  duration&amp; operator=(const duration&amp;) = default;

  template &lt;class Rep2&gt;
  constexpr explicit duration(const Rep2&amp; r);

  template &lt;class Rep2, class Period2&gt;
  constexpr duration(const duration&lt;Rep2, Period2&gt;&amp; d);

  constexpr rep count() const;
  constexpr duration operator+() const;
  constexpr duration operator-() const;

  duration&amp; operator++();
  duration operator++(int);
  duration&amp; operator--();
  duration operator--(int);

  duration&amp; operator+=(const duration&amp; d);
  duration&amp; operator-=(const duration&amp; d);
  duration&amp; operator*=(const rep&amp; rhs);
  duration&amp; operator/=(const rep&amp; rhs);

  duration&amp; operator%=(const rep&amp; rhs);
  duration&amp; operator%=(const duration&amp; rhs);

  static constexpr duration zero();
  static constexpr duration min();
  static constexpr duration max();
};

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator==(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
    constexpr bool operator!=(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
    constexpr bool operator&lt;(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
    constexpr bool operator&lt;=(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
    constexpr bool operator&gt;(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
    constexpr bool operator&gt;=(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class ToDuration, class Rep, class Period&gt;
    constexpr ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);
</code></pre>
<p><strong>要求</strong></p>
<p><code>Rep</code>必须是内置数值类型，或是自定义的类数值类型。</p>
<p><code>Period</code>必须是<code>std::ratio&lt;&gt;</code>实例。</p>
<h3 id="stdchronodurationrep-类型"><a class="header" href="#stdchronodurationrep-类型">std::chrono::duration::Rep 类型</a></h3>
<p>用来记录<code>dration</code>中时钟周期的数量。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef Rep rep;
</code></pre>
<p><code>rep</code>类型用来记录<code>duration</code>对象内部的表示。</p>
<h3 id="stdchronodurationperiod-类型"><a class="header" href="#stdchronodurationperiod-类型">std::chrono::duration::Period 类型</a></h3>
<p>这个类型必须是一个<code>std::ratio</code>特化实例，用来表示在继续时间中，1s所要记录的次数。例如，当<code>period</code>是<code>std::ratio&lt;1, 50&gt;</code>，<code>duration</code>变量的count()就会在N秒钟返回50N。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef Period period;
</code></pre>
<h3 id="stdchronoduration-默认构造函数"><a class="header" href="#stdchronoduration-默认构造函数">std::chrono::duration 默认构造函数</a></h3>
<p>使用默认值构造<code>std::chrono::duration</code>实例</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">constexpr duration() = default;
</code></pre>
<p><strong>效果</strong>
<code>duration</code>内部值(例如<code>rep</code>类型的值)都已初始化。</p>
<h3 id="stdchronoduration-需要计数值的转换构造函数"><a class="header" href="#stdchronoduration-需要计数值的转换构造函数">std::chrono::duration 需要计数值的转换构造函数</a></h3>
<p>通过给定的数值来构造<code>std::chrono::duration</code>实例。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class Rep2&gt;;
constexpr explicit duration(const Rep2&amp; r);
</code></pre>
<p><strong>效果</strong></p>
<p><code>duration</code>对象的内部值会使用<code>static_cast&lt;rep&gt;(r)</code>进行初始化。</p>
<p><strong>结果</strong>
当Rep2隐式转换为Rep，Rep是浮点类型或Rep2不是浮点类型，这个构造函数才能使用。</p>
<p><strong>后验条件</strong></p>
<pre><code class="language-c++">this-&gt;count()==static_cast&lt;rep&gt;(r)
</code></pre>
<h3 id="stdchronoduration-需要另一个stdchronoduration值的转化构造函数"><a class="header" href="#stdchronoduration-需要另一个stdchronoduration值的转化构造函数">std::chrono::duration 需要另一个std::chrono::duration值的转化构造函数</a></h3>
<p>通过另一个<code>std::chrono::duration</code>类实例中的计数值来构造一个<code>std::chrono::duration</code>类实例。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class Rep2, class Period&gt;
constexpr duration(const duration&lt;Rep2,Period2&gt;&amp; d);
</code></pre>
<p><strong>结果</strong></p>
<p>duration对象的内部值通过<code>duration_cast&lt;duration&lt;Rep,Period&gt;&gt;(d).count()</code>初始化。</p>
<p><strong>要求</strong></p>
<p>当Rep是一个浮点类或Rep2不是浮点类，且Period2是Period数的倍数(比如，ratio_divide&lt;Period2,Period&gt;::den==1)时，才能调用该重载。当一个较小的数据转换为一个较大的数据时，使用该构造函数就能避免数位截断和精度损失。</p>
<p><strong>后验条件</strong></p>
<p><code>this-&gt;count() == dutation_cast&amp;lt;duration&lt;Rep, Period&gt;&gt;(d).count()</code></p>
<p><strong>例子</strong></p>
<pre><code class="language-c++">duration&lt;int, ratio&lt;1, 1000&gt;&gt; ms(5);  // 5毫秒
duration&lt;int, ratio&lt;1, 1&gt;&gt; s(ms);  // 错误：不能将ms当做s进行存储
duration&lt;double, ratio&lt;1,1&gt;&gt; s2(ms);  // 合法：s2.count() == 0.005
duration&lt;int, ration&lt;1, 1000000&gt;&gt; us&lt;ms&gt;;  // 合法:us.count() == 5000
</code></pre>
<h3 id="stdchronodurationcount-成员函数"><a class="header" href="#stdchronodurationcount-成员函数">std::chrono::duration::count 成员函数</a></h3>
<p>查询持续时长。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">constexpr rep count() const;
</code></pre>
<p><strong>返回</strong></p>
<p>返回duration的内部值，其值类型和rep一样。</p>
<h3 id="stdchronodurationoperator-加法操作符"><a class="header" href="#stdchronodurationoperator-加法操作符">std::chrono::duration::operator+ 加法操作符</a></h3>
<p>这是一个空操作：只会返回*this的副本。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">constexpr duration operator+() const;
</code></pre>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronodurationoperator--减法操作符"><a class="header" href="#stdchronodurationoperator--减法操作符">std::chrono::duration::operator- 减法操作符</a></h3>
<p>返回将内部值只为负数的*this副本。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">constexpr duration operator-() const;
</code></pre>
<p><strong>返回</strong>
<code>duration(--this-&gt;count());</code></p>
<h3 id="stdchronodurationoperator-前置自加操作符"><a class="header" href="#stdchronodurationoperator-前置自加操作符">std::chrono::duration::operator++ 前置自加操作符</a></h3>
<p>增加内部计数值。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration&amp; operator++();
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">++this-&gt;internal_count;
</code></pre>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronodurationoperator-后置自加操作符"><a class="header" href="#stdchronodurationoperator-后置自加操作符">std::chrono::duration::operator++ 后置自加操作符</a></h3>
<p>自加内部计数值，并且返回还没有增加前的*this。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration operator++(int);
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">duration temp(*this);
++(*this);
return temp;
</code></pre>
<h3 id="stdchronodurationoperator---前置自减操作符"><a class="header" href="#stdchronodurationoperator---前置自减操作符">std::chrono::duration::operator-- 前置自减操作符</a></h3>
<p>自减内部计数值</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration&amp; operator--();
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">--this-&gt;internal_count;
</code></pre>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronodurationoperator---前置自减操作符-1"><a class="header" href="#stdchronodurationoperator---前置自减操作符-1">std::chrono::duration::operator-- 前置自减操作符</a></h3>
<p>自减内部计数值，并且返回还没有减少前的*this。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration operator--(int);
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">duration temp(*this);
--(*this);
return temp;
</code></pre>
<h3 id="stdchronodurationoperator-复合赋值操作符"><a class="header" href="#stdchronodurationoperator-复合赋值操作符">std::chrono::duration::operator+= 复合赋值操作符</a></h3>
<p>将其他duration对象中的内部值增加到现有duration对象当中。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration&amp; operator+=(duration const&amp; other);
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">internal_count+=other.count();
</code></pre>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronodurationoperator--复合赋值操作符"><a class="header" href="#stdchronodurationoperator--复合赋值操作符">std::chrono::duration::operator-= 复合赋值操作符</a></h3>
<p>现有duration对象减去其他duration对象中的内部值。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration&amp; operator-=(duration const&amp; other);
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">internal_count-=other.count();
</code></pre>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronodurationoperator-复合赋值操作符-1"><a class="header" href="#stdchronodurationoperator-复合赋值操作符-1">std::chrono::duration::operator*= 复合赋值操作符</a></h3>
<p>内部值乘以一个给定的值。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration&amp; operator*=(rep const&amp; rhs);
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">internal_count*=rhs;
</code></pre>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronodurationoperator-复合赋值操作符-2"><a class="header" href="#stdchronodurationoperator-复合赋值操作符-2">std::chrono::duration::operator/= 复合赋值操作符</a></h3>
<p>内部值除以一个给定的值。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration&amp; operator/=(rep const&amp; rhs);
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">internal_count/=rhs;
</code></pre>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronodurationoperator-复合赋值操作符-3"><a class="header" href="#stdchronodurationoperator-复合赋值操作符-3">std::chrono::duration::operator%= 复合赋值操作符</a></h3>
<p>内部值对一个给定的值求余。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration&amp; operator%=(rep const&amp; rhs);
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">internal_count%=rhs;
</code></pre>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronodurationoperator-复合赋值操作符重载"><a class="header" href="#stdchronodurationoperator-复合赋值操作符重载">std::chrono::duration::operator%= 复合赋值操作符(重载)</a></h3>
<p>内部值对另一个duration类的内部值求余。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration&amp; operator%=(duration const&amp; rhs);
</code></pre>
<p><strong>结果</strong></p>
<pre><code class="language-c++">internal_count%=rhs.count();
</code></pre>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronodurationzero-静态成员函数"><a class="header" href="#stdchronodurationzero-静态成员函数">std::chrono::duration::zero 静态成员函数</a></h3>
<p>返回一个内部值为0的duration对象。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">constexpr duration zero();
</code></pre>
<p><strong>返回</strong></p>
<pre><code class="language-c++">duration(duration_values&lt;rep&gt;::zero());
</code></pre>
<h3 id="stdchronodurationmin-静态成员函数"><a class="header" href="#stdchronodurationmin-静态成员函数">std::chrono::duration::min 静态成员函数</a></h3>
<p>返回duration类实例化后能表示的最小值。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">constexpr duration min();
</code></pre>
<p><strong>返回</strong></p>
<pre><code class="language-c++">duration(duration_values&lt;rep&gt;::min());
</code></pre>
<h3 id="stdchronodurationmax-静态成员函数"><a class="header" href="#stdchronodurationmax-静态成员函数">std::chrono::duration::max 静态成员函数</a></h3>
<p>返回duration类实例化后能表示的最大值。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">constexpr duration max();
</code></pre>
<p><strong>返回</strong></p>
<pre><code class="language-c++">duration(duration_values&lt;rep&gt;::max());
</code></pre>
<h3 id="stdchronoduration-等于比较操作符"><a class="header" href="#stdchronoduration-等于比较操作符">std::chrono::duration 等于比较操作符</a></h3>
<p>比较两个duration对象是否相等。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator==(
const duration&lt;Rep1, Period1&gt;&amp; lhs,
const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></pre>
<p><strong>要求</strong></p>
<p><code>lhs</code>和<code>rhs</code>两种类型可以互相进行隐式转换。当两种类型无法进行隐式转换，或是可以互相转换的两个不同类型的duration类，则表达式不合理。</p>
<p><strong>结果</strong></p>
<p>当<code>CommonDuration</code>和<code>std::common_type&lt; duration&lt; Rep1, Period1&gt;, duration&lt; Rep2, Period2&gt;&gt;::type</code>同类，那么<code>lhs==rhs</code>就会返回<code>CommonDuration(lhs).count()==CommonDuration(rhs).count()</code>。</p>
<h3 id="stdchronoduration-不等于比较操作符"><a class="header" href="#stdchronoduration-不等于比较操作符">std::chrono::duration 不等于比较操作符</a></h3>
<p>比较两个duration对象是否不相等。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator!=(
   const duration&lt;Rep1, Period1&gt;&amp; lhs,
   const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></pre>
<p><strong>要求</strong></p>
<p><code>lhs</code>和<code>rhs</code>两种类型可以互相进行隐式转换。当两种类型无法进行隐式转换，或是可以互相转换的两个不同类型的duration类，则表达式不合理。</p>
<p><strong>返回</strong>
<code>!(lhs==rhs)</code></p>
<h3 id="stdchronoduration-小于比较操作符"><a class="header" href="#stdchronoduration-小于比较操作符">std::chrono::duration 小于比较操作符</a></h3>
<p>比较两个duration对象是否小于。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&lt;(
   const duration&lt;Rep1, Period1&gt;&amp; lhs,
   const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></pre>
<p><strong>要求</strong></p>
<p><code>lhs</code>和<code>rhs</code>两种类型可以互相进行隐式转换。当两种类型无法进行隐式转换，或是可以互相转换的两个不同类型的duration类，则表达式不合理。</p>
<p><strong>结果</strong></p>
<p>当<code>CommonDuration</code>和<code>std::common_type&lt; duration&lt; Rep1, Period1&gt;, duration&lt; Rep2, Period2&gt;&gt;::type</code>同类，那么<code>lhs&amp;lt;rhs</code>就会返回<code>CommonDuration(lhs).count()&amp;lt;CommonDuration(rhs).count()</code>。</p>
<h3 id="stdchronoduration-大于比较操作符"><a class="header" href="#stdchronoduration-大于比较操作符">std::chrono::duration 大于比较操作符</a></h3>
<p>比较两个duration对象是否大于。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&gt;(
   const duration&lt;Rep1, Period1&gt;&amp; lhs,
   const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></pre>
<p><strong>要求</strong></p>
<p><code>lhs</code>和<code>rhs</code>两种类型可以互相进行隐式转换。当两种类型无法进行隐式转换，或是可以互相转换的两个不同类型的duration类，则表达式不合理。</p>
<p><strong>返回</strong>
<code>rhs&lt;lhs</code></p>
<h3 id="stdchronoduration-小于等于比较操作符"><a class="header" href="#stdchronoduration-小于等于比较操作符">std::chrono::duration 小于等于比较操作符</a></h3>
<p>比较两个duration对象是否小于等于。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&lt;=(
   const duration&lt;Rep1, Period1&gt;&amp; lhs,
   const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></pre>
<p><strong>要求</strong></p>
<p><code>lhs</code>和<code>rhs</code>两种类型可以互相进行隐式转换。当两种类型无法进行隐式转换，或是可以互相转换的两个不同类型的duration类，则表达式不合理。</p>
<p><strong>返回</strong>
<code>!(rhs&lt;lhs)</code></p>
<h3 id="stdchronoduration-大于等于比较操作符"><a class="header" href="#stdchronoduration-大于等于比较操作符">std::chrono::duration 大于等于比较操作符</a></h3>
<p>比较两个duration对象是否大于等于。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&gt;=(
   const duration&lt;Rep1, Period1&gt;&amp; lhs,
   const duration&lt;Rep2, Period2&gt;&amp; rhs);
</code></pre>
<p><strong>要求</strong></p>
<p><code>lhs</code>和<code>rhs</code>两种类型可以互相进行隐式转换。当两种类型无法进行隐式转换，或是可以互相转换的两个不同类型的duration类，则表达式不合理。</p>
<p><strong>返回</strong>
<code>!(lhs&lt;rhs)</code></p>
<h3 id="stdchronoduration_cast-非成员函数"><a class="header" href="#stdchronoduration_cast-非成员函数">std::chrono::duration_cast 非成员函数</a></h3>
<p>显示将一个<code>std::chrono::duration</code>对象转化为另一个<code>std::chrono::duration</code>实例。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class ToDuration, class Rep, class Period&gt;
constexpr ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);
</code></pre>
<p><strong>要求</strong></p>
<p>ToDuration必须是<code>std::chrono::duration</code>的实例。</p>
<p><strong>返回</strong></p>
<p>duration类d转换为指定类型ToDuration。这种方式可以在不同尺寸和表示类型的转换中尽可能减少精度损失。</p>
<h2 id="d12-stdchronotime_point类型模板"><a class="header" href="#d12-stdchronotime_point类型模板">D.1.2 std::chrono::time_point类型模板</a></h2>
<p><code>std::chrono::time_point</code>类型模板通过(特别的)时钟来表示某个时间点。这个时钟代表的是从epoch(1970-01-01 00:00:00 UTC，作为UNIX系列系统的特定时间戳)到现在的时间。模板参数Clock代表使用的使用(不同的使用必定有自己独特的类型)，而Duration模板参数使用来测量从epoch到现在的时间，并且这个参数的类型必须是<code>std::chrono::duration</code>类型。Duration默认存储Clock上的测量值。</p>
<h3 id="类型定义"><a class="header" href="#类型定义">类型定义</a></h3>
<pre><code class="language-c++">template &lt;class Clock,class Duration = typename Clock::duration&gt;
class time_point
{
public:
  typedef Clock clock;
  typedef Duration duration;
  typedef typename duration::rep rep;
  typedef typename duration::period period;
  
  time_point();
  explicit time_point(const duration&amp; d);

  template &lt;class Duration2&gt;
  time_point(const time_point&lt;clock, Duration2&gt;&amp; t);

  duration time_since_epoch() const;
  
  time_point&amp; operator+=(const duration&amp; d);
  time_point&amp; operator-=(const duration&amp; d);
  
  static constexpr time_point min();
  static constexpr time_point max();
};
</code></pre>
<h3 id="stdchronotime_point-默认构造函数"><a class="header" href="#stdchronotime_point-默认构造函数">std::chrono::time_point 默认构造函数</a></h3>
<p>构造time_point代表着，使用相关的Clock，记录从epoch到现在的时间；其内部计时使用Duration::zero()进行初始化。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">time_point();
</code></pre>
<p><strong>后验条件</strong></p>
<p>对于使用默认构造函数构造出的time_point对象tp，<code>tp.time_since_epoch() == tp::duration::zero()</code>。</p>
<h3 id="stdchronotime_point-需要时间长度的构造函数"><a class="header" href="#stdchronotime_point-需要时间长度的构造函数">std::chrono::time_point 需要时间长度的构造函数</a></h3>
<p>构造time_point代表着，使用相关的Clock，记录从epoch到现在的时间。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">explicit time_point(const duration&amp; d);
</code></pre>
<p><strong>后验条件</strong></p>
<p>当有一个time_point对象tp，是通过duration d构造出来的(tp(d))，那么<code>tp.time_since_epoch() == d</code>。</p>
<h3 id="stdchronotime_point-转换构造函数"><a class="header" href="#stdchronotime_point-转换构造函数">std::chrono::time_point 转换构造函数</a></h3>
<p>构造time_point代表着，使用相关的Clock，记录从epoch到现在的时间。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">template &lt;class Duration2&gt;
time_point(const time_point&lt;clock, Duration2&gt;&amp; t);
</code></pre>
<p><strong>要求</strong></p>
<p>Duration2必须呢个隐式转换为Duration。</p>
<p><strong>效果</strong></p>
<p>当<code>time_point(t.time_since_epoch())</code>存在，从t.time_since_epoch()中获取的返回值，可以隐式转换成Duration类型的对象，并且这个值可以存储在一个新的time_point对象中。</p>
<p>(扩展阅读：<a href="http://stackoverflow.com/questions/15718262/what-exactly-is-the-as-if-rule">as-if准则</a>)</p>
<h3 id="stdchronotime_pointtime_since_epoch-成员函数"><a class="header" href="#stdchronotime_pointtime_since_epoch-成员函数">std::chrono::time_point::time_since_epoch 成员函数</a></h3>
<p>返回当前time_point从epoch到现在的具体时长。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">duration time_since_epoch() const;
</code></pre>
<p><strong>返回</strong></p>
<p>duration的值存储在*this中。</p>
<h3 id="stdchronotime_pointoperator-复合赋值函数"><a class="header" href="#stdchronotime_pointoperator-复合赋值函数">std::chrono::time_point::operator+= 复合赋值函数</a></h3>
<p>将指定的duration的值与原存储在指定的time_point对象中的duration相加，并将加后值存储在*this对象中。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">time_point&amp; operator+=(const duration&amp; d);
</code></pre>
<p><strong>效果</strong></p>
<p>将d的值和duration对象的值相加，存储在*this中，就如同this-&gt;internal_duration += d;</p>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronotime_pointoperator--复合赋值函数"><a class="header" href="#stdchronotime_pointoperator--复合赋值函数">std::chrono::time_point::operator-= 复合赋值函数</a></h3>
<p>将指定的duration的值与原存储在指定的time_point对象中的duration相减，并将加后值存储在*this对象中。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">time_point&amp; operator-=(const duration&amp; d);
</code></pre>
<p><strong>效果</strong></p>
<p>将d的值和duration对象的值相减，存储在*this中，就如同this-&gt;internal_duration -= d;</p>
<p><strong>返回</strong>
<code>*this</code></p>
<h3 id="stdchronotime_pointmin-静态成员函数"><a class="header" href="#stdchronotime_pointmin-静态成员函数">std::chrono::time_point::min 静态成员函数</a></h3>
<p>获取time_point对象可能表示的最小值。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">static constexpr time_point min();
</code></pre>
<p><strong>返回</strong></p>
<pre><code class="language-c++">time_point(time_point::duration::min()) (see 11.1.1.15)
</code></pre>
<h3 id="stdchronotime_pointmax-静态成员函数"><a class="header" href="#stdchronotime_pointmax-静态成员函数">std::chrono::time_point::max 静态成员函数</a></h3>
<p>获取time_point对象可能表示的最大值。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">static constexpr time_point max();
</code></pre>
<p><strong>返回</strong></p>
<pre><code class="language-c++">time_point(time_point::duration::max()) (see 11.1.1.16)
</code></pre>
<p>##D.1.3 std::chrono::system_clock类</p>
<p><code>std::chrono::system_clock</code>类提供给了从系统实时时钟上获取当前时间功能。可以调用<code>std::chrono::system_clock::now()</code>来获取当前的时间。<code>std::chrono::system_clock::time_point</code>也可以通过<code>std::chrono::system_clock::to_time_t()</code>和<code>std::chrono::system_clock::to_time_point()</code>函数返回值转换成time_t类型。系统时钟不稳定，所以<code>std::chrono::system_clock::now()</code>获取到的时间可能会早于之前的一次调用(比如，时钟被手动调整过或与外部时钟进行了同步)。</p>
<p>###类型定义</p>
<pre><code class="language-c++">class system_clock
{
public:
  typedef unspecified-integral-type rep;
  typedef std::ratio&lt;unspecified,unspecified&gt; period;
  typedef std::chrono::duration&lt;rep,period&gt; duration;
  typedef std::chrono::time_point&lt;system_clock&gt; time_point;
  static const bool is_steady=unspecified;

  static time_point now() noexcept;

  static time_t to_time_t(const time_point&amp; t) noexcept;
  static time_point from_time_t(time_t t) noexcept;
};
</code></pre>
<h3 id="stdchronosystem_clockrep-类型定义"><a class="header" href="#stdchronosystem_clockrep-类型定义">std::chrono::system_clock::rep 类型定义</a></h3>
<p>将时间周期数记录在一个duration值中</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef unspecified-integral-type rep;
</code></pre>
<h3 id="stdchronosystem_clockperiod-类型定义"><a class="header" href="#stdchronosystem_clockperiod-类型定义">std::chrono::system_clock::period 类型定义</a></h3>
<p>类型为<code>std::ratio</code>类型模板，通过在两个不同的duration或time_point间特化最小秒数(或将1秒分为好几份)。period指定了时钟的精度，而非时钟频率。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef std::ratio&lt;unspecified,unspecified&gt; period;
</code></pre>
<h3 id="stdchronosystem_clockduration-类型定义"><a class="header" href="#stdchronosystem_clockduration-类型定义">std::chrono::system_clock::duration 类型定义</a></h3>
<p>类型为<code>std::ratio</code>类型模板，通过系统实时时钟获取两个时间点之间的时长。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef std::chrono::duration&lt;
   std::chrono::system_clock::rep,
   std::chrono::system_clock::period&gt; duration;
</code></pre>
<h3 id="stdchronosystem_clocktime_point-类型定义"><a class="header" href="#stdchronosystem_clocktime_point-类型定义">std::chrono::system_clock::time_point 类型定义</a></h3>
<p>类型为<code>std::ratio</code>类型模板，通过系统实时时钟获取当前时间点的时间。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef std::chrono::time_point&amp;lt;std::chrono::system_clock&amp;gt; time_point;
</code></pre>
<h3 id="stdchronosystem_clocknow-静态成员函数"><a class="header" href="#stdchronosystem_clocknow-静态成员函数">std::chrono::system_clock::now 静态成员函数</a></h3>
<p>从系统实时时钟上获取当前的外部设备显示的时间。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">time_point now() noexcept;
</code></pre>
<p><strong>返回</strong></p>
<p>time_point类型变量来代表当前系统实时时钟的时间。</p>
<p><strong>抛出</strong></p>
<p>当错误发生，<code>std::system_error</code>异常将会抛出。</p>
<h3 id="stdchronosystem_clockto_time_t-静态成员函数"><a class="header" href="#stdchronosystem_clockto_time_t-静态成员函数">std::chrono::system_clock:to_time_t 静态成员函数</a></h3>
<p>将time_point类型值转化为time_t。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">time_t to_time_t(time_point const&amp; t) noexcept;
</code></pre>
<p><strong>返回</strong></p>
<p>通过对t进行舍入或截断精度，将其转化为一个time_t类型的值。</p>
<p><strong>抛出</strong></p>
<p>当错误发生，<code>std::system_error</code>异常将会抛出。</p>
<h3 id="stdchronosystem_clockfrom_time_t-静态成员函数"><a class="header" href="#stdchronosystem_clockfrom_time_t-静态成员函数">std::chrono::system_clock::from_time_t 静态成员函数</a></h3>
<p><strong>声明</strong></p>
<pre><code class="language-c++">time_point from_time_t(time_t const&amp; t) noexcept;
</code></pre>
<p><strong>返回</strong></p>
<p>time_point中的值与t中的值一样。</p>
<p><strong>抛出</strong></p>
<p>当错误发生，<code>std::system_error</code>异常将会抛出。</p>
<h2 id="d14-stdchronosteady_clock类"><a class="header" href="#d14-stdchronosteady_clock类">D.1.4 std::chrono::steady_clock类</a></h2>
<p><code>std::chrono::steady_clock</code>能访问系统稳定时钟。可以通过调用<code>std::chrono::steady_clock::now()</code>获取当前的时间。设备上显示的时间，与使用<code>std::chrono::steady_clock::now()</code>获取的时间没有固定的关系。稳定时钟是无法回调的，所以在<code>std::chrono::steady_clock::now()</code>两次调用后，第二次调用获取的时间必定等于或大于第一次获得的时间。</p>
<h3 id="类型定义-1"><a class="header" href="#类型定义-1">类型定义</a></h3>
<pre><code class="language-c++">class steady_clock
{
public:
  typedef unspecified-integral-type rep;
  typedef std::ratio&lt;
      unspecified,unspecified&gt; period;
  typedef std::chrono::duration&lt;rep,period&gt; duration;
  typedef std::chrono::time_point&lt;steady_clock&gt;
      time_point;
  static const bool is_steady=true;

  static time_point now() noexcept;
};
</code></pre>
<h3 id="stdchronosteady_clockrep-类型定义"><a class="header" href="#stdchronosteady_clockrep-类型定义">std::chrono::steady_clock::rep 类型定义</a></h3>
<p>定义一个整型，用来保存duration的值。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef unspecified-integral-type rep;
</code></pre>
<h3 id="stdchronosteady_clockperiod-类型定义"><a class="header" href="#stdchronosteady_clockperiod-类型定义">std::chrono::steady_clock::period 类型定义</a></h3>
<p>类型为<code>std::ratio</code>类型模板，通过在两个不同的duration或time_point间特化最小秒数(或将1秒分为好几份)。period指定了时钟的精度，而非时钟频率。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef std::ratio&lt;unspecified,unspecified&gt; period;
</code></pre>
<h3 id="stdchronosteady_clockduration-类型定义"><a class="header" href="#stdchronosteady_clockduration-类型定义">std::chrono::steady_clock::duration 类型定义</a></h3>
<p>类型为<code>std::ratio</code>类型模板，通过系统实时时钟获取两个时间点之间的时长。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef std::chrono::duration&lt;
   std::chrono::system_clock::rep,
   std::chrono::system_clock::period&gt; duration;
</code></pre>
<h3 id="stdchronosteady_clocktime_point-类型定义"><a class="header" href="#stdchronosteady_clocktime_point-类型定义">std::chrono::steady_clock::time_point 类型定义</a></h3>
<p><code>std::chrono::time_point</code>类型实例，可以存储从系统稳定时钟返回的时间点。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">typedef std::chrono::time_point&lt;std::chrono::steady_clock&gt; time_point;
</code></pre>
<h3 id="stdchronosteady_clocknow-静态成员函数"><a class="header" href="#stdchronosteady_clocknow-静态成员函数">std::chrono::steady_clock::now 静态成员函数</a></h3>
<p>从系统稳定时钟获取当前时间。</p>
<p><strong>声明</strong></p>
<pre><code class="language-c++">time_point now() noexcept;
</code></pre>
<p><strong>返回</strong></p>
<p>time_point表示当前系统稳定时钟的时间。</p>
<p><strong>抛出</strong>
当遇到错误，会抛出<code>std::system_error</code>异常。</p>
<p><strong>同步</strong>
当先行调用过一次<code>std::chrono::steady_clock::now()</code>，那么下一次time_point获取的值，一定大于等于第一次获取的值。</p>
<h2 id="d15-stdchronohigh_resolution_clock类定义"><a class="header" href="#d15-stdchronohigh_resolution_clock类定义">D.1.5 std::chrono::high_resolution_clock类定义</a></h2>
<p><code>td::chrono::high_resolution_clock</code>类能访问系统高精度时钟。和所有其他时钟一样，通过调用<code>std::chrono::high_resolution_clock::now()</code>来获取当前时间。<code>std::chrono::high_resolution_clock</code>可能是<code>std::chrono::system_clock</code>类或<code>std::chrono::steady_clock</code>类的别名，也可能就是独立的一个类。</p>
<p>通过<code>std::chrono::high_resolution_clock</code>具有所有标准库支持时钟中最高的精度，这就意味着使用
<code>std::chrono::high_resolution_clock::now()</code>要花掉一些时间。所以，当你再调用<code>std::chrono::high_resolution_clock::now()</code>的时候，需要注意函数本身的时间开销。</p>
<h3 id="类型定义-2"><a class="header" href="#类型定义-2">类型定义</a></h3>
<pre><code class="language-c++">class high_resolution_clock
{
public:
  typedef unspecified-integral-type rep;
  typedef std::ratio&lt;
      unspecified,unspecified&gt; period;
  typedef std::chrono::duration&lt;rep,period&gt; duration;
  typedef std::chrono::time_point&lt;
      unspecified&gt; time_point;
  static const bool is_steady=unspecified;

  static time_point now() noexcept;
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../content/appendix_D/D.0-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../content/appendix_D/D.2-chinese.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../content/appendix_D/D.0-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../content/appendix_D/D.2-chinese.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
