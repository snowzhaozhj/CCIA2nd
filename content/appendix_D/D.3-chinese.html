<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>D.3 atomic头文件 - C++ConcurrencyInAction</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../content/Praise_for_the_first_edition.html"><strong aria-hidden="true">1.</strong> 第一版的赞许</a></li><li class="chapter-item expanded "><a href="../../content/preface-chinese.html"><strong aria-hidden="true">2.</strong> 前言</a></li><li class="chapter-item expanded "><a href="../../content/acknowledgments-chinese.html"><strong aria-hidden="true">3.</strong> 感谢</a></li><li class="chapter-item expanded "><a href="../../content/about_this_book-chinese.html"><strong aria-hidden="true">4.</strong> 关于本书</a></li><li class="chapter-item expanded "><a href="../../content/about_the_author-chinese.html"><strong aria-hidden="true">5.</strong> 关于作者</a></li><li class="chapter-item expanded "><a href="../../content/about_cover_illustration-chinese.html"><strong aria-hidden="true">6.</strong> 关于封面</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.0-chinese.html"><strong aria-hidden="true">7.</strong> 第1章 你好，并发世界</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter1/1.1-chinese.html"><strong aria-hidden="true">7.1.</strong> 1.1 何谓并发</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.2-chinese.html"><strong aria-hidden="true">7.2.</strong> 1.2 为什么使用并发</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.3-chinese.html"><strong aria-hidden="true">7.3.</strong> 1.3 并发和多线程</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.4-chinese.html"><strong aria-hidden="true">7.4.</strong> 1.4 开始入门</a></li><li class="chapter-item expanded "><a href="../../content/chapter1/1.5-chinese.html"><strong aria-hidden="true">7.5.</strong> 1.5 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.0-chinese.html"><strong aria-hidden="true">8.</strong> 第2章 线程管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter2/2.1-chinese.html"><strong aria-hidden="true">8.1.</strong> 2.1 线程的基本操作</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.2-chinese.html"><strong aria-hidden="true">8.2.</strong> 2.2 传递参数</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.3-chinese.html"><strong aria-hidden="true">8.3.</strong> 2.3 转移所有权</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.4-chinese.html"><strong aria-hidden="true">8.4.</strong> 2.4 确定线程数量</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.5-chinese.html"><strong aria-hidden="true">8.5.</strong> 2.5 线程标识</a></li><li class="chapter-item expanded "><a href="../../content/chapter2/2.6-chinese.html"><strong aria-hidden="true">8.6.</strong> 2.6 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.0-chinese.html"><strong aria-hidden="true">9.</strong> 第3章 共享数据</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter3/3.1-chinese.html"><strong aria-hidden="true">9.1.</strong> 3.1 共享数据的问题</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.2-chinese.html"><strong aria-hidden="true">9.2.</strong> 3.2 使用互斥量</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.3-chinese.html"><strong aria-hidden="true">9.3.</strong> 3.3 保护共享数据的方式</a></li><li class="chapter-item expanded "><a href="../../content/chapter3/3.4-chinese.html"><strong aria-hidden="true">9.4.</strong> 3.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.0-chinese.html"><strong aria-hidden="true">10.</strong> 第4章 同步操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter4/4.1-chinese.html"><strong aria-hidden="true">10.1.</strong> 4.1 等待事件或条件</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.2-chinese.html"><strong aria-hidden="true">10.2.</strong> 4.2 使用future</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.3-chinese.html"><strong aria-hidden="true">10.3.</strong> 4.3 限时等待</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.4-chinese.html"><strong aria-hidden="true">10.4.</strong> 4.4 简化代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter4/4.5-chinese.html"><strong aria-hidden="true">10.5.</strong> 4.5 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.0-chinese.html"><strong aria-hidden="true">11.</strong> 第5章 内存模型和原子操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter5/5.1-chinese.html"><strong aria-hidden="true">11.1.</strong> 5.1 内存模型</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.2-chinese.html"><strong aria-hidden="true">11.2.</strong> 5.2 原子操作和原子类型</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.3-chinese.html"><strong aria-hidden="true">11.3.</strong> 5.3 同步操作和强制排序</a></li><li class="chapter-item expanded "><a href="../../content/chapter5/5.4-chinese.html"><strong aria-hidden="true">11.4.</strong> 5.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.0-chinese.html"><strong aria-hidden="true">12.</strong> 第6章 设计基于锁的并发数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter6/6.1-chinese.html"><strong aria-hidden="true">12.1.</strong> 6.1 并发设计的意义</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.2-chinese.html"><strong aria-hidden="true">12.2.</strong> 6.2 基于锁的并发数据结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.3-chinese.html"><strong aria-hidden="true">12.3.</strong> 6.3 设计更加复杂的数据结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter6/6.4-chinese.html"><strong aria-hidden="true">12.4.</strong> 6.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.0-chinese.html"><strong aria-hidden="true">13.</strong> 第7章 设计无锁的并发数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter7/7.1-chinese.html"><strong aria-hidden="true">13.1.</strong> 7.1 定义和意义</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.2-chinese.html"><strong aria-hidden="true">13.2.</strong> 7.2 无锁数据结构的例子</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.3-chinese.html"><strong aria-hidden="true">13.3.</strong> 7.3 设计无锁数据结构的指导建议</a></li><li class="chapter-item expanded "><a href="../../content/chapter7/7.4-chinese.html"><strong aria-hidden="true">13.4.</strong> 7.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.0-chinese.html"><strong aria-hidden="true">14.</strong> 第8章 并发设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter8/8.1-chinese.html"><strong aria-hidden="true">14.1.</strong> 8.1 线程间划分工作</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.2-chinese.html"><strong aria-hidden="true">14.2.</strong> 8.2 并发代码的性能</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.3-chinese.html"><strong aria-hidden="true">14.3.</strong> 8.3 为多线程性能设计数据结构</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.4-chinese.html"><strong aria-hidden="true">14.4.</strong> 8.4 设计并发代码的注意事项</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.5-chinese.html"><strong aria-hidden="true">14.5.</strong> 8.5 在实践中设计并发代码</a></li><li class="chapter-item expanded "><a href="../../content/chapter8/8.6-chinese.html"><strong aria-hidden="true">14.6.</strong> 8.6 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.0-chinese.html"><strong aria-hidden="true">15.</strong> 第9章 高级线程管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter9/9.1-chinese.html"><strong aria-hidden="true">15.1.</strong> 9.1 线程池</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.2-chinese.html"><strong aria-hidden="true">15.2.</strong> 9.2 中断线程</a></li><li class="chapter-item expanded "><a href="../../content/chapter9/9.3-chinese.html"><strong aria-hidden="true">15.3.</strong> 9.3 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.0-chinese.html"><strong aria-hidden="true">16.</strong> 第10章 并行算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter10/10.1-chinese.html"><strong aria-hidden="true">16.1.</strong> 10.1 并行化标准库算法</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.2-chinese.html"><strong aria-hidden="true">16.2.</strong> 10.2 执行策略</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.3-chinese.html"><strong aria-hidden="true">16.3.</strong> 10.3 C++标准库中的并行算法</a></li><li class="chapter-item expanded "><a href="../../content/chapter10/10.4-chinese.html"><strong aria-hidden="true">16.4.</strong> 10.4 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.0-chinese.html"><strong aria-hidden="true">17.</strong> 第11章 测试和调试多线程应用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/chapter11/11.1-chinese.html"><strong aria-hidden="true">17.1.</strong> 11.1 与并发相关的Bug</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.2-chinese.html"><strong aria-hidden="true">17.2.</strong> 11.2 定位并发Bug的技巧</a></li><li class="chapter-item expanded "><a href="../../content/chapter11/11.3-chinese.html"><strong aria-hidden="true">17.3.</strong> 11.3 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.0-chinese.html"><strong aria-hidden="true">18.</strong> 附录A C++11特性简明参考(部分)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/appendix_A/A.1-chinese.html"><strong aria-hidden="true">18.1.</strong> A.1 右值引用</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.2-chinese.html"><strong aria-hidden="true">18.2.</strong> A.2 删除函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.3-chinese.html"><strong aria-hidden="true">18.3.</strong> A.3 默认函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.4-chinese.html"><strong aria-hidden="true">18.4.</strong> A.4 常量表达式函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.5-chinese.html"><strong aria-hidden="true">18.5.</strong> A.5 Lambda函数</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.6-chinese.html"><strong aria-hidden="true">18.6.</strong> A.6 变参模板</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.7-chinese.html"><strong aria-hidden="true">18.7.</strong> A.7 自动推导变量类型</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.8-chinese.html"><strong aria-hidden="true">18.8.</strong> A.8 线程本地变量</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.9-chinese.html"><strong aria-hidden="true">18.9.</strong> A.9 模板类参数的推导</a></li><li class="chapter-item expanded "><a href="../../content/appendix_A/A.10-chinese.html"><strong aria-hidden="true">18.10.</strong> A.10 本章总结</a></li></ol></li><li class="chapter-item expanded "><a href="../../content/appendix_B/B.0-chinese.html"><strong aria-hidden="true">19.</strong> 附录B 并发库简要对比</a></li><li class="chapter-item expanded "><a href="../../content/appendix_C/C.0-chinese.html"><strong aria-hidden="true">20.</strong> 附录C 消息传递框架与完整的ATM示例</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.0-chinese.html"><strong aria-hidden="true">21.</strong> 附录D C++线程类库参考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../content/appendix_D/D.1-chinese.html"><strong aria-hidden="true">21.1.</strong> D.1 chrono头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.2-chinese.html"><strong aria-hidden="true">21.2.</strong> D.2 condition_variable头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.3-chinese.html" class="active"><strong aria-hidden="true">21.3.</strong> D.3 atomic头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.4-chinese.html"><strong aria-hidden="true">21.4.</strong> D.4 future头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.5-chinese.html"><strong aria-hidden="true">21.5.</strong> D.5 mutex头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.6-chinese.html"><strong aria-hidden="true">21.6.</strong> D.6 ratio头文件</a></li><li class="chapter-item expanded "><a href="../../content/appendix_D/D.7-chinese.html"><strong aria-hidden="true">21.7.</strong> D.7 thread头文件</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">C++ConcurrencyInAction</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="d3-atomic头文件"><a class="header" href="#d3-atomic头文件">D.3 &lt;atomic&gt;头文件</a></h1>
<p>&lt;atomic&gt;头文件提供一组基础的原子类型，和提供对这些基本类型的操作，以及一个原子模板函数，用来接收用户定义的类型，以适用于某些标准。</p>
<p>###头文件内容</p>
<pre><code>#define ATOMIC_BOOL_LOCK_FREE 参见详述
#define ATOMIC_CHAR_LOCK_FREE 参见详述
#define ATOMIC_SHORT_LOCK_FREE 参见详述
#define ATOMIC_INT_LOCK_FREE 参见详述
#define ATOMIC_LONG_LOCK_FREE 参见详述
#define ATOMIC_LLONG_LOCK_FREE 参见详述
#define ATOMIC_CHAR16_T_LOCK_FREE 参见详述
#define ATOMIC_CHAR32_T_LOCK_FREE 参见详述
#define ATOMIC_WCHAR_T_LOCK_FREE 参见详述
#define ATOMIC_POINTER_LOCK_FREE 参见详述

#define ATOMIC_VAR_INIT(value) 参见详述

namespace std
{
  enum memory_order;

  struct atomic_flag;
  参见类型定义详述 atomic_bool;
  参见类型定义详述 atomic_char;
  参见类型定义详述 atomic_char16_t;
  参见类型定义详述 atomic_char32_t;
  参见类型定义详述 atomic_schar;
  参见类型定义详述 atomic_uchar;
  参见类型定义详述 atomic_short;
  参见类型定义详述 atomic_ushort;
  参见类型定义详述 atomic_int;
  参见类型定义详述 atomic_uint;
  参见类型定义详述 atomic_long;
  参见类型定义详述 atomic_ulong;
  参见类型定义详述 atomic_llong;
  参见类型定义详述 atomic_ullong;
  参见类型定义详述 atomic_wchar_t;

  参见类型定义详述 atomic_int_least8_t;
  参见类型定义详述 atomic_uint_least8_t;
  参见类型定义详述 atomic_int_least16_t;
  参见类型定义详述 atomic_uint_least16_t;
  参见类型定义详述 atomic_int_least32_t;
  参见类型定义详述 atomic_uint_least32_t;
  参见类型定义详述 atomic_int_least64_t;
  参见类型定义详述 atomic_uint_least64_t;
  参见类型定义详述 atomic_int_fast8_t;
  参见类型定义详述 atomic_uint_fast8_t;
  参见类型定义详述 atomic_int_fast16_t;
  参见类型定义详述 atomic_uint_fast16_t;
  参见类型定义详述 atomic_int_fast32_t;
  参见类型定义详述 atomic_uint_fast32_t;
  参见类型定义详述 atomic_int_fast64_t;
  参见类型定义详述 atomic_uint_fast64_t;
  参见类型定义详述 atomic_int8_t;
  参见类型定义详述 atomic_uint8_t;
  参见类型定义详述 atomic_int16_t;
  参见类型定义详述 atomic_uint16_t;
  参见类型定义详述 atomic_int32_t;
  参见类型定义详述 atomic_uint32_t;
  参见类型定义详述 atomic_int64_t;
  参见类型定义详述 atomic_uint64_t;
  参见类型定义详述 atomic_intptr_t;
  参见类型定义详述 atomic_uintptr_t;
  参见类型定义详述 atomic_size_t;
  参见类型定义详述 atomic_ssize_t;
  参见类型定义详述 atomic_ptrdiff_t;
  参见类型定义详述 atomic_intmax_t;
  参见类型定义详述 atomic_uintmax_t;

  template&lt;typename T&gt;
  struct atomic;

  extern &quot;C&quot; void atomic_thread_fence(memory_order order);
  extern &quot;C&quot; void atomic_signal_fence(memory_order order);

  template&lt;typename T&gt;
  T kill_dependency(T);
}
</code></pre>
<h2 id="stdatomic_xxx类型定义"><a class="header" href="#stdatomic_xxx类型定义">std::atomic_xxx类型定义</a></h2>
<p>为了兼容新的C标准(C11)，C++支持定义原子整型类型。这些类型都与<code>std::atimic&lt;T&gt;;</code>特化类相对应，或是用同一接口特化的一个基本类型。</p>
<p><strong>Table D.1 原子类型定义和与之相关的std::atmoic&lt;&gt;特化模板</strong></p>
<table><thead><tr><th>std::atomic_itype 原子类型</th><th>std::atomic&lt;&gt; 相关特化类</th></tr></thead><tbody>
<tr><td>atomic_char</td><td>std::atomic&lt;char&gt;</td></tr>
<tr><td>atomic_schar</td><td>std::atomic&lt;signed char&gt;</td></tr>
<tr><td>atomic_uchar</td><td>std::atomic&lt;unsigned char&gt;</td></tr>
<tr><td>atomic_int</td><td>std::atomic&lt;int&gt;</td></tr>
<tr><td>atomic_uint</td><td>std::atomic&lt;unsigned&gt;</td></tr>
<tr><td>atomic_short</td><td>std::atomic&lt;short&gt;</td></tr>
<tr><td>atomic_ushort</td><td>std::atomic&lt;unsigned short&gt;</td></tr>
<tr><td>atomic_long</td><td>std::atomic&lt;long&gt;</td></tr>
<tr><td>atomic_ulong</td><td>std::atomic&lt;unsigned long&gt;</td></tr>
<tr><td>atomic_llong</td><td>std::atomic&lt;long long&gt;</td></tr>
<tr><td>atomic_ullong</td><td>std::atomic&lt;unsigned long long&gt;</td></tr>
<tr><td>atomic_wchar_t</td><td>std::atomic&lt;wchar_t&gt;</td></tr>
<tr><td>atomic_char16_t</td><td>std::atomic&lt;char16_t&gt;</td></tr>
<tr><td>atomic_char32_t</td><td>std::atomic&lt;char32_t&gt;</td></tr>
</tbody></table>
<p>(译者注：该表与第5章中的表5.1几乎一致)</p>
<h2 id="d32-atomic_xxx_lock_free宏"><a class="header" href="#d32-atomic_xxx_lock_free宏">D.3.2 ATOMIC_xxx_LOCK_FREE宏</a></h2>
<p>这里的宏指定了原子类型与其内置类型是否是无锁的。</p>
<p><strong>宏定义</strong></p>
<pre><code>#define ATOMIC_BOOL_LOCK_FREE 参见详述
#define ATOMIC_CHAR_LOCK_FREE参见详述
#define ATOMIC_SHORT_LOCK_FREE 参见详述
#define ATOMIC_INT_LOCK_FREE 参见详述
#define ATOMIC_LONG_LOCK_FREE 参见详述
#define ATOMIC_LLONG_LOCK_FREE 参见详述
#define ATOMIC_CHAR16_T_LOCK_FREE 参见详述
#define ATOMIC_CHAR32_T_LOCK_FREE 参见详述
#define ATOMIC_WCHAR_T_LOCK_FREE 参见详述
#define ATOMIC_POINTER_LOCK_FREE 参见详述
</code></pre>
<p><code>ATOMIC_xxx_LOCK_FREE</code>的值无非就是0，1，2。0意味着，在对有无符号的相关原子类型操作是有锁的；1意味着，操作只对一些特定的类型上锁，而对没有指定的类型不上锁；2意味着，所有操作都是无锁的。例如，当<code>ATOMIC_INT_LOCK_FREE</code>是2的时候，在<code>std::atomic&amp;lt;int&amp;gt;</code>和<code>std::atomic&amp;lt;unsigned&amp;gt;</code>上的操作始终无锁。</p>
<p>宏<code>ATOMIC_POINTER_LOCK_FREE</code>描述了，对于特化的原子类型指针<code>std::atomic&lt;T*&gt;</code>操作的无锁特性。</p>
<h2 id="d33-atomic_var_init宏"><a class="header" href="#d33-atomic_var_init宏">D.3.3 ATOMIC_VAR_INIT宏</a></h2>
<p><code>ATOMIC_VAR_INIT</code>宏可以通过一个特定的值来初始化一个原子变量。</p>
<p><strong>声明</strong>
<code>#define ATOMIC_VAR_INIT(value)参见详述</code></p>
<p>宏可以扩展成一系列符号，这个宏可以通过一个给定值，初始化一个标准原子类型，表达式如下所示：</p>
<pre><code>std::atomic&lt;type&gt; x = ATOMIC_VAR_INIT(val);
</code></pre>
<p>给定值可以兼容与原子变量相关的非原子变量，例如：</p>
<pre><code>std::atomic&amp;lt;int&gt; i = ATOMIC_VAR_INIT(42);
std::string s;
std::atomic&amp;lt;std::string*&gt; p = ATOMIC_VAR_INIT(&amp;s);
</code></pre>
<p>这样初始化的变量是非原子的，并且在变量初始化之后，其他线程可以随意的访问该变量，这样可以避免条件竞争和未定义行为的发生。</p>
<h2 id="d34-stdmemory_order枚举类型"><a class="header" href="#d34-stdmemory_order枚举类型">D.3.4 std::memory_order枚举类型</a></h2>
<p><code>std::memory_order</code>枚举类型用来表明原子操作的约束顺序。</p>
<p><strong>声明</strong></p>
<pre><code>typedef enum memory_order
{
  memory_order_relaxed,memory_order_consume,
  memory_order_acquire,memory_order_release,
  memory_order_acq_rel,memory_order_seq_cst
} memory_order;
</code></pre>
<p>通过标记各种内存序变量来标记操作的顺序(详见第5章，在该章节中有对书序约束更加详尽的介绍)</p>
<h3 id="stdmemory_order_relaxed"><a class="header" href="#stdmemory_order_relaxed">std::memory_order_relaxed</a></h3>
<p>操作不受任何额外的限制。</p>
<h3 id="stdmemory_order_release"><a class="header" href="#stdmemory_order_release">std::memory_order_release</a></h3>
<p>对于指定位置上的内存可进行释放操作。因此，与获取操作读取同一内存位置所存储的值。</p>
<h3 id="stdmemory_order_acquire"><a class="header" href="#stdmemory_order_acquire">std::memory_order_acquire</a></h3>
<p>操作可以获取指定内存位置上的值。当需要存储的值通过释放操作写入时，是与存储操同步的。</p>
<h3 id="stdmemory_order_acq_rel"><a class="header" href="#stdmemory_order_acq_rel">std::memory_order_acq_rel</a></h3>
<p>操作必须是“读-改-写”操作，并且其行为需要在<code>std::memory_order_acquire</code>和<code>std::memory_order_release</code>序指定的内存位置上进行操作。</p>
<h3 id="stdmemory_order_seq_cst"><a class="header" href="#stdmemory_order_seq_cst">std::memory_order_seq_cst</a></h3>
<p>操作在全局序上都会受到约束。还有，当为存储操作时，其行为好比<code>std::memory_order_release</code>操作；当为加载操作时，其行为好比<code>std::memory_order_acquire</code>操作；并且，当其是一个“读-改-写”操作时，其行为和<code>std::memory_order_acquire</code>和<code>std::memory_order_release</code>类似。对于所有顺序来说，该顺序为默认序。</p>
<h3 id="stdmemory_order_consume"><a class="header" href="#stdmemory_order_consume">std::memory_order_consume</a></h3>
<p>对于指定位置的内存进行消耗操作(consume operation)。</p>
<p>(译者注：与memory_order_acquire类似)</p>
<p>##D.3.5 std::atomic_thread_fence函数</p>
<p><code>std::atomic_thread_fence()</code>会在代码中插入“内存栅栏”，强制两个操作保持内存约束顺序。</p>
<p><strong>声明</strong></p>
<pre><code>extern &quot;C&quot; void atomic_thread_fence(std::memory_order order);
</code></pre>
<p><strong>效果</strong>
插入栅栏的目的是为了保证内存序的约束性。</p>
<p>栅栏使用<code>std::memory_order_release</code>, <code>std::memory_order_acq_rel</code>, 或 <code>std::memory_order_seq_cst</code>内存序，会同步与一些内存位置上的获取操作进行同步，如果这些获取操作要获取一个已存储的值(通过原子操作进行的存储)，就会通过栅栏进行同步。</p>
<p>释放操作可对<code>std::memory_order_acquire</code>, <code>std::memory_order_acq_rel</code>, 或 <code>std::memory_order_seq_cst</code>进行栅栏同步，；当释放操作存储的值，在一个原子操作之前读取，那么就会通过栅栏进行同步。</p>
<p><strong>抛出</strong>
无</p>
<h2 id="d36-stdatomic_signal_fence函数"><a class="header" href="#d36-stdatomic_signal_fence函数">D.3.6 std::atomic_signal_fence函数</a></h2>
<p><code>std::atomic_signal_fence()</code>会在代码中插入“内存栅栏”，强制两个操作保持内存约束顺序，并且在对应线程上执行信号处理操作。</p>
<p><strong>声明</strong></p>
<pre><code>extern &quot;C&quot; void atomic_signal_fence(std::memory_order order);
</code></pre>
<p><strong>效果</strong>
根据需要的内存约束序插入一个栅栏。除非约束序应用于“操作和信号处理函数在同一线程”的情况下，否则，这个操作等价于<code>std::atomic_thread_fence(order)</code>操作。</p>
<p><strong>抛出</strong>
无</p>
<h2 id="d37-stdatomic_flag类"><a class="header" href="#d37-stdatomic_flag类">D.3.7 std::atomic_flag类</a></h2>
<p><code>std::atomic_flag</code>类算是原子标识的骨架。在C++11标准下，只有这个数据类型可以保证是无锁的(当然，更多的原子类型在未来的实现中将采取无锁实现)。</p>
<p>对于一个<code>std::atomic_flag</code>来说，其状态不是set，就是clear。</p>
<p><strong>类型定义</strong></p>
<pre><code>struct atomic_flag
{
  atomic_flag() noexcept = default;
  atomic_flag(const atomic_flag&amp;) = delete;
  atomic_flag&amp; operator=(const atomic_flag&amp;) = delete;
  atomic_flag&amp; operator=(const atomic_flag&amp;) volatile = delete;

  bool test_and_set(memory_order = memory_order_seq_cst) volatile
    noexcept;
  bool test_and_set(memory_order = memory_order_seq_cst) noexcept;
  void clear(memory_order = memory_order_seq_cst) volatile noexcept;
  void clear(memory_order = memory_order_seq_cst) noexcept;
};

bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
bool atomic_flag_test_and_set(atomic_flag*) noexcept;
bool atomic_flag_test_and_set_explicit(
  volatile atomic_flag*, memory_order) noexcept;
bool atomic_flag_test_and_set_explicit(
  atomic_flag*, memory_order) noexcept;
void atomic_flag_clear(volatile atomic_flag*) noexcept;
void atomic_flag_clear(atomic_flag*) noexcept;
void atomic_flag_clear_explicit(
  volatile atomic_flag*, memory_order) noexcept;
void atomic_flag_clear_explicit(
  atomic_flag*, memory_order) noexcept;

#define ATOMIC_FLAG_INIT unspecified
</code></pre>
<h3 id="stdatomic_flag-默认构造函数"><a class="header" href="#stdatomic_flag-默认构造函数">std::atomic_flag 默认构造函数</a></h3>
<p>这里未指定默认构造出来的<code>std::atomic_flag</code>实例是clear状态，还是set状态。因为对象存储过程是静态的，所以初始化必须是静态的。</p>
<p><strong>声明</strong></p>
<pre><code>std::atomic_flag() noexcept = default;
</code></pre>
<p><strong>效果</strong>
构造一个新<code>std::atomic_flag</code>对象，不过未指明状态。(薛定谔的猫？)</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdatomic_flag-使用atomic_flag_init进行初始化"><a class="header" href="#stdatomic_flag-使用atomic_flag_init进行初始化">std::atomic_flag 使用ATOMIC_FLAG_INIT进行初始化</a></h3>
<p><code>std::atomic_flag</code>实例可以使用<code>ATOMIC_FLAG_INIT</code>宏进行创建，这样构造出来的实例状态为clear。因为对象存储过程是静态的，所以初始化必须是静态的。</p>
<p><strong>声明</strong></p>
<pre><code>#define ATOMIC_FLAG_INIT unspecified
</code></pre>
<p><strong>用法</strong></p>
<pre><code>std::atomic_flag flag=ATOMIC_FLAG_INIT;
</code></pre>
<p><strong>效果</strong>
构造一个新<code>std::atomic_flag</code>对象，状态为clear。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>：
对于内存位置上的*this，这个操作属于“读-改-写”操作。</p>
<h3 id="stdatomic_flagtest_and_set-成员函数"><a class="header" href="#stdatomic_flagtest_and_set-成员函数">std::atomic_flag::test_and_set 成员函数</a></h3>
<p>自动设置实例状态标识，并且检查实例的状态标识是否已经设置。</p>
<p><strong>声明</strong></p>
<pre><code>bool atomic_flag_test_and_set(volatile atomic_flag* flag) noexcept;
bool atomic_flag_test_and_set(atomic_flag* flag) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return flag-&gt;test_and_set();
</code></pre>
<h3 id="stdatomic_flag_test_and_set-非成员函数"><a class="header" href="#stdatomic_flag_test_and_set-非成员函数">std::atomic_flag_test_and_set 非成员函数</a></h3>
<p>自动设置原子变量的状态标识，并且检查原子变量的状态标识是否已经设置。</p>
<p><strong>声明</strong></p>
<pre><code>bool atomic_flag_test_and_set_explicit(
    volatile atomic_flag* flag, memory_order order) noexcept;
bool atomic_flag_test_and_set_explicit(
    atomic_flag* flag, memory_order order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return flag-&gt;test_and_set(order);
</code></pre>
<h3 id="stdatomic_flag_test_and_set_explicit-非成员函数"><a class="header" href="#stdatomic_flag_test_and_set_explicit-非成员函数">std::atomic_flag_test_and_set_explicit 非成员函数</a></h3>
<p>自动设置原子变量的状态标识，并且检查原子变量的状态标识是否已经设置。</p>
<p><strong>声明</strong></p>
<pre><code>bool atomic_flag_test_and_set_explicit(
    volatile atomic_flag* flag, memory_order order) noexcept;
bool atomic_flag_test_and_set_explicit(
    atomic_flag* flag, memory_order order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return flag-&gt;test_and_set(order);
</code></pre>
<h3 id="stdatomic_flagclear-成员函数"><a class="header" href="#stdatomic_flagclear-成员函数">std::atomic_flag::clear 成员函数</a></h3>
<p>自动清除原子变量的状态标识。</p>
<p><strong>声明</strong></p>
<pre><code>void clear(memory_order order = memory_order_seq_cst) volatile noexcept;
void clear(memory_order order = memory_order_seq_cst) noexcept;
</code></pre>
<p><strong>先决条件</strong>
支持<code>std::memory_order_relaxed</code>,<code>std::memory_order_release</code>和<code>std::memory_order_seq_cst</code>中任意一个。</p>
<p><strong>效果</strong>
自动清除变量状态标识。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:对于内存位置上的*this，这个操作属于“写”操作(存储操作)。</p>
<h3 id="stdatomic_flag_clear-非成员函数"><a class="header" href="#stdatomic_flag_clear-非成员函数">std::atomic_flag_clear 非成员函数</a></h3>
<p>自动清除原子变量的状态标识。</p>
<p><strong>声明</strong></p>
<pre><code>void atomic_flag_clear(volatile atomic_flag* flag) noexcept;
void atomic_flag_clear(atomic_flag* flag) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>flag-&gt;clear();
</code></pre>
<h3 id="stdatomic_flag_clear_explicit-非成员函数"><a class="header" href="#stdatomic_flag_clear_explicit-非成员函数">std::atomic_flag_clear_explicit 非成员函数</a></h3>
<p>自动清除原子变量的状态标识。</p>
<p><strong>声明</strong></p>
<pre><code>void atomic_flag_clear_explicit(
    volatile atomic_flag* flag, memory_order order) noexcept;
void atomic_flag_clear_explicit(
    atomic_flag* flag, memory_order order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return flag-&gt;clear(order);
</code></pre>
<p>##D.3.8 std::atomic类型模板</p>
<p><code>std::atomic</code>提供了对任意类型的原子操作的包装，以满足下面的需求。</p>
<p>模板参数BaseType必须满足下面的条件。</p>
<ul>
<li>具有简单的默认构造函数</li>
<li>具有简单的拷贝赋值操作</li>
<li>具有简单的析构函数</li>
<li>可以进行位比较</li>
</ul>
<p>这就意味着<code>std::atomic&amp;lt;some-simple-struct&amp;gt;</code>会和使用<code>std::atomic&lt;some-built-in-type&gt;</code>一样简单；不过对于<code>std::atomic&lt;std::string&gt;</code>就不同了。</p>
<p>除了主模板，对于内置整型和指针的特化，模板也支持类似x++这样的操作。</p>
<p><code>std::atomic</code>实例是不支持<code>CopyConstructible</code>(拷贝构造)和<code>CopyAssignable</code>(拷贝赋值)，原因你懂得，因为这样原子操作就无法执行。</p>
<p><strong>类型定义</strong></p>
<pre><code>template&lt;typename BaseType&gt;
struct atomic
{
  atomic() noexcept = default;
  constexpr atomic(BaseType) noexcept;
  BaseType operator=(BaseType) volatile noexcept;
  BaseType operator=(BaseType) noexcept;

  atomic(const atomic&amp;) = delete;
  atomic&amp; operator=(const atomic&amp;) = delete;
  atomic&amp; operator=(const atomic&amp;) volatile = delete;

  bool is_lock_free() const volatile noexcept;
  bool is_lock_free() const noexcept;

  void store(BaseType,memory_order = memory_order_seq_cst)
      volatile noexcept;
  void store(BaseType,memory_order = memory_order_seq_cst) noexcept;
  BaseType load(memory_order = memory_order_seq_cst)
      const volatile noexcept;
  BaseType load(memory_order = memory_order_seq_cst) const noexcept;
  BaseType exchange(BaseType,memory_order = memory_order_seq_cst)
      volatile noexcept;
  BaseType exchange(BaseType,memory_order = memory_order_seq_cst)
      noexcept;

  bool compare_exchange_strong(
      BaseType &amp; old_value, BaseType new_value,
      memory_order order = memory_order_seq_cst) volatile noexcept;
  bool compare_exchange_strong(
      BaseType &amp; old_value, BaseType new_value,
      memory_order order = memory_order_seq_cst) noexcept;
  bool compare_exchange_strong(
      BaseType &amp; old_value, BaseType new_value,
      memory_order success_order,
      memory_order failure_order) volatile noexcept;
  bool compare_exchange_strong(
      BaseType &amp; old_value, BaseType new_value,
      memory_order success_order,
      memory_order failure_order) noexcept;
  bool compare_exchange_weak(
      BaseType &amp; old_value, BaseType new_value,
      memory_order order = memory_order_seq_cst)
      volatile noexcept;
  bool compare_exchange_weak(
      BaseType &amp; old_value, BaseType new_value,
      memory_order order = memory_order_seq_cst) noexcept;
  bool compare_exchange_weak(
      BaseType &amp; old_value, BaseType new_value,
      memory_order success_order,
      memory_order failure_order) volatile noexcept;
  bool compare_exchange_weak(
      BaseType &amp; old_value, BaseType new_value,
      memory_order success_order,
      memory_order failure_order) noexcept;
      operator BaseType () const volatile noexcept;
      operator BaseType () const noexcept;
};

template&lt;typename BaseType&gt;
bool atomic_is_lock_free(volatile const atomic&lt;BaseType&gt;*) noexcept;
template&lt;typename BaseType&gt;
bool atomic_is_lock_free(const atomic&lt;BaseType&gt;*) noexcept;
template&lt;typename BaseType&gt;
void atomic_init(volatile atomic&lt;BaseType&gt;*, void*) noexcept;
template&lt;typename BaseType&gt;
void atomic_init(atomic&lt;BaseType&gt;*, void*) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange(volatile atomic&lt;BaseType&gt;*, memory_order)
  noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange(atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange_explicit(
  volatile atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange_explicit(
  atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
void atomic_store(volatile atomic&lt;BaseType&gt;*, BaseType) noexcept;
template&lt;typename BaseType&gt;
void atomic_store(atomic&lt;BaseType&gt;*, BaseType) noexcept;
template&lt;typename BaseType&gt;
void atomic_store_explicit(
  volatile atomic&lt;BaseType&gt;*, BaseType, memory_order) noexcept;
template&lt;typename BaseType&gt;
void atomic_store_explicit(
  atomic&lt;BaseType&gt;*, BaseType, memory_order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load(volatile const atomic&lt;BaseType&gt;*) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load(const atomic&lt;BaseType&gt;*) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load_explicit(
  volatile const atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load_explicit(
  const atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong(
  volatile atomic&lt;BaseType&gt;*,BaseType * old_value,
  BaseType new_value) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong(
  atomic&lt;BaseType&gt;*,BaseType * old_value,
  BaseType new_value) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong_explicit(
  volatile atomic&lt;BaseType&gt;*,BaseType * old_value,
  BaseType new_value, memory_order success_order,
  memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong_explicit(
  atomic&lt;BaseType&gt;*,BaseType * old_value,
  BaseType new_value, memory_order success_order,
  memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak(
  volatile atomic&lt;BaseType&gt;*,BaseType * old_value,BaseType new_value)
  noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak(
  atomic&lt;BaseType&gt;*,BaseType * old_value,BaseType new_value) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak_explicit(
  volatile atomic&lt;BaseType&gt;*,BaseType * old_value,
  BaseType new_value, memory_order success_order,
  memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak_explicit(
  atomic&lt;BaseType&gt;*,BaseType * old_value,
  BaseType new_value, memory_order success_order,
  memory_order failure_order) noexcept;
</code></pre>
<p><strong>NOTE</strong>:虽然非成员函数通过模板的方式指定，不过他们只作为从在函数提供，并且对于这些函数，不能显示的指定模板的参数。</p>
<h3 id="stdatomic-构造函数"><a class="header" href="#stdatomic-构造函数">std::atomic 构造函数</a></h3>
<p>使用默认初始值，构造一个<code>std::atomic</code>实例。</p>
<p><strong>声明</strong></p>
<pre><code>atomic() noexcept;
</code></pre>
<p><strong>效果</strong>
使用默认初始值，构造一个新<code>std::atomic</code>实例。因对象是静态存储的，所以初始化过程也是静态的。</p>
<p><strong>NOTE</strong>:当<code>std::atomic</code>实例以非静态方式初始化的，那么其值就是不可估计的。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdatomic_init-非成员函数"><a class="header" href="#stdatomic_init-非成员函数">std::atomic_init 非成员函数</a></h3>
<p><code>std::atomic&lt;BaseType&gt;</code>实例提供的值，可非原子的进行存储。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
void atomic_init(atomic&lt;BaseType&gt; volatile* p, BaseType v) noexcept;
template&lt;typename BaseType&gt;
void atomic_init(atomic&lt;BaseType&gt;* p, BaseType v) noexcept;
</code></pre>
<p><strong>效果</strong>
将值v以非原子存储的方式，存储在*p中。调用<code>atomic&lt;BaseType&gt;</code>实例中的atomic_init()，这里需要实例不是默认构造出来的，或者在构造出来的时候被执行了某些操作，否则将会引发未定义行为。</p>
<p><strong>NOTE</strong>:因为存储是非原子的，对对象指针p任意的并发访问(即使是原子操作)都会引发数据竞争。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdatomic-转换构造函数"><a class="header" href="#stdatomic-转换构造函数">std::atomic 转换构造函数</a></h3>
<p>使用提供的BaseType值去构造一个<code>std::atomic</code>实例。</p>
<p><strong>声明</strong></p>
<pre><code>constexpr atomic(BaseType b) noexcept;
</code></pre>
<p><strong>效果</strong>
通过b值构造一个新的<code>std::atomic</code>对象。因对象是静态存储的，所以初始化过程也是静态的。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdatomic-转换赋值操作"><a class="header" href="#stdatomic-转换赋值操作">std::atomic 转换赋值操作</a></h3>
<p>在*this存储一个新值。</p>
<p><strong>声明</strong></p>
<pre><code>BaseType operator=(BaseType b) volatile noexcept;
BaseType operator=(BaseType b) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;store(b);
</code></pre>
<h3 id="stdatomicis_lock_free-成员函数"><a class="header" href="#stdatomicis_lock_free-成员函数">std::atomic::is_lock_free 成员函数</a></h3>
<p>确定对于*this是否是无锁操作。</p>
<p><strong>声明</strong></p>
<pre><code>bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
</code></pre>
<p><strong>返回</strong>
当操作是无锁操作，那么就返回true，否则返回false。</p>
<p><strong>抛出</strong>
无</p>
<h3 id="stdatomic_is_lock_free-非成员函数"><a class="header" href="#stdatomic_is_lock_free-非成员函数">std::atomic_is_lock_free 非成员函数</a></h3>
<p>确定对于*this是否是无锁操作。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
bool atomic_is_lock_free(volatile const atomic&lt;BaseType&gt;* p) noexcept;
template&lt;typename BaseType&gt;
bool atomic_is_lock_free(const atomic&lt;BaseType&gt;* p) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;is_lock_free();
</code></pre>
<h3 id="stdatomicload-成员函数"><a class="header" href="#stdatomicload-成员函数">std::atomic::load 成员函数</a></h3>
<p>原子的加载<code>std::atomic</code>实例当前的值</p>
<p><strong>声明</strong></p>
<pre><code>BaseType load(memory_order order = memory_order_seq_cst)
    const volatile noexcept;
BaseType load(memory_order order = memory_order_seq_cst) const noexcept;
</code></pre>
<p><strong>先决条件</strong>
支持<code>std::memory_order_relaxed</code>、<code>std::memory_order_acquire</code>、<code>std::memory_order_consume</code>或<code>std::memory_order_seq_cst</code>内存序。</p>
<p><strong>效果</strong>
原子的加载已存储到*this上的值。</p>
<p><strong>返回</strong>
返回存储在*this上的值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:是对于*this内存地址原子加载的操作。</p>
<h3 id="stdatomic_load-非成员函数"><a class="header" href="#stdatomic_load-非成员函数">std::atomic_load 非成员函数</a></h3>
<p>原子的加载<code>std::atomic</code>实例当前的值。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
BaseType atomic_load(volatile const atomic&lt;BaseType&gt;* p) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load(const atomic&lt;BaseType&gt;* p) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;load();
</code></pre>
<h3 id="stdatomic_load_explicit-非成员函数"><a class="header" href="#stdatomic_load_explicit-非成员函数">std::atomic_load_explicit 非成员函数</a></h3>
<p>原子的加载<code>std::atomic</code>实例当前的值。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
BaseType atomic_load_explicit(
    volatile const atomic&lt;BaseType&gt;* p, memory_order order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load_explicit(
    const atomic&lt;BaseType&gt;* p, memory_order order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;load(order);
</code></pre>
<h3 id="stdatomicoperator-basttype转换操作"><a class="header" href="#stdatomicoperator-basttype转换操作">std::atomic::operator BastType转换操作</a></h3>
<p>加载存储在*this中的值。</p>
<p><strong>声明</strong></p>
<pre><code>operator BaseType() const volatile noexcept;
operator BaseType() const noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;load();
</code></pre>
<h3 id="stdatomicstore-成员函数"><a class="header" href="#stdatomicstore-成员函数">std::atomic::store 成员函数</a></h3>
<p>以原子操作的方式存储一个新值到<code>atomic&lt;BaseType&gt;</code>实例中。</p>
<p><strong>声明</strong></p>
<pre><code>void store(BaseType new_value,memory_order order = memory_order_seq_cst)
    volatile noexcept;
void store(BaseType new_value,memory_order order = memory_order_seq_cst)
    noexcept;
</code></pre>
<p><strong>先决条件</strong>
支持<code>std::memory_order_relaxed</code>、<code>std::memory_order_release</code>或<code>std::memory_order_seq_cst</code>内存序。</p>
<p><strong>效果</strong>
将new_value原子的存储到*this中。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:是对于*this内存地址原子加载的操作。</p>
<h3 id="stdatomic_store-非成员函数"><a class="header" href="#stdatomic_store-非成员函数">std::atomic_store 非成员函数</a></h3>
<p>以原子操作的方式存储一个新值到<code>atomic&amp;lt;BaseType&amp;gt;</code>实例中。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
void atomic_store(volatile atomic&lt;BaseType&gt;* p, BaseType new_value)
    noexcept;
template&lt;typename BaseType&gt;
void atomic_store(atomic&lt;BaseType&gt;* p, BaseType new_value) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>p-&gt;store(new_value);
</code></pre>
<h3 id="stdatomic_explicit-非成员函数"><a class="header" href="#stdatomic_explicit-非成员函数">std::atomic_explicit 非成员函数</a></h3>
<p>以原子操作的方式存储一个新值到<code>atomic&amp;lt;BaseType&amp;gt;</code>实例中。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
void atomic_store_explicit(
    volatile atomic&lt;BaseType&gt;* p, BaseType new_value, memory_order order)
    noexcept;
template&lt;typename BaseType&gt;
void atomic_store_explicit(
    atomic&lt;BaseType&gt;* p, BaseType new_value, memory_order order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>p-&gt;store(new_value,order);
</code></pre>
<h3 id="stdatomicexchange-成员函数"><a class="header" href="#stdatomicexchange-成员函数">std::atomic::exchange 成员函数</a></h3>
<p>原子的存储一个新值，并读取旧值。</p>
<p><strong>声明</strong></p>
<pre><code>BaseType exchange(
    BaseType new_value,
    memory_order order = memory_order_seq_cst)
    volatile noexcept;
</code></pre>
<p><strong>效果</strong>
原子的将new_value存储在<em>this中，并且取出</em>this中已经存储的值。</p>
<p><strong>返回</strong>
返回*this之前的值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:这是对*this内存地址的原子“读-改-写”操作。</p>
<h3 id="stdatomic_exchange-非成员函数"><a class="header" href="#stdatomic_exchange-非成员函数">std::atomic_exchange 非成员函数</a></h3>
<p>原子的存储一个新值到<code>atomic&lt;BaseType&gt;</code>实例中，并且读取旧值。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
BaseType atomic_exchange(volatile atomic&lt;BaseType&gt;* p, BaseType new_value)
    noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange(atomic&lt;BaseType&gt;* p, BaseType new_value) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;exchange(new_value);
</code></pre>
<h3 id="stdatomic_exchange_explicit-非成员函数"><a class="header" href="#stdatomic_exchange_explicit-非成员函数">std::atomic_exchange_explicit 非成员函数</a></h3>
<p>原子的存储一个新值到<code>atomic&lt;BaseType&gt;</code>实例中，并且读取旧值。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
BaseType atomic_exchange_explicit(
    volatile atomic&lt;BaseType&gt;* p, BaseType new_value, memory_order order)
    noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange_explicit(
    atomic&lt;BaseType&gt;* p, BaseType new_value, memory_order order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;exchange(new_value,order);
</code></pre>
<h3 id="stdatomiccompare_exchange_strong-成员函数"><a class="header" href="#stdatomiccompare_exchange_strong-成员函数">std::atomic::compare_exchange_strong 成员函数</a></h3>
<p>当期望值和新值一样时，将新值存储到实例中。如果不相等，那么就实用新值更新期望值。</p>
<p><strong>声明</strong></p>
<pre><code>bool compare_exchange_strong(
    BaseType&amp; expected,BaseType new_value,
    memory_order order = std::memory_order_seq_cst) volatile noexcept;
bool compare_exchange_strong(
    BaseType&amp; expected,BaseType new_value,
    memory_order order = std::memory_order_seq_cst) noexcept;
bool compare_exchange_strong(
    BaseType&amp; expected,BaseType new_value,
    memory_order success_order,memory_order failure_order)
    volatile noexcept;
bool compare_exchange_strong(
    BaseType&amp; expected,BaseType new_value,
    memory_order success_order,memory_order failure_order) noexcept;
</code></pre>
<p><strong>先决条件</strong>
failure_order不能是<code>std::memory_order_release</code>或<code>std::memory_order_acq_rel</code>内存序。</p>
<p><strong>效果</strong>
将存储在<em>this中的expected值与new_value值进行逐位对比，当相等时间new_value存储在</em>this中；否则，更新expected的值。</p>
<p><strong>返回</strong>
当new_value的值与*this中已经存在的值相同，就返回true；否则，返回false。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:在success_order==order和failure_order==order的情况下，三个参数的重载函数与四个参数的重载函数等价。除非，order是<code>std::memory_order_acq_rel</code>时，failure_order是<code>std::memory_order_acquire</code>，且当order是<code>std::memory_order_release</code>时，failure_order是<code>std::memory_order_relaxed</code>。</p>
<p><strong>NOTE</strong>:当返回true和success_order内存序时，是对<em>this内存地址的原子“读-改-写”操作；反之，这是对</em>this内存地址的原子加载操作(failure_order)。</p>
<h3 id="stdatomic_compare_exchange_strong-非成员函数"><a class="header" href="#stdatomic_compare_exchange_strong-非成员函数">std::atomic_compare_exchange_strong 非成员函数</a></h3>
<p>当期望值和新值一样时，将新值存储到实例中。如果不相等，那么就实用新值更新期望值。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong(
    volatile atomic&lt;BaseType&gt;* p,BaseType * old_value,BaseType new_value)
    noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong(  
    atomic&lt;BaseType&gt;* p,BaseType * old_value,BaseType new_value) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;compare_exchange_strong(*old_value,new_value);
</code></pre>
<h3 id="stdatomic_compare_exchange_strong_explicit-非成员函数"><a class="header" href="#stdatomic_compare_exchange_strong_explicit-非成员函数">std::atomic_compare_exchange_strong_explicit 非成员函数</a></h3>
<p>当期望值和新值一样时，将新值存储到实例中。如果不相等，那么就实用新值更新期望值。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong_explicit(
    volatile atomic&lt;BaseType&gt;* p,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong_explicit(
    atomic&lt;BaseType&gt;* p,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;compare_exchange_strong(
    *old_value,new_value,success_order,failure_order) noexcept;
</code></pre>
<h3 id="stdatomiccompare_exchange_weak-成员函数"><a class="header" href="#stdatomiccompare_exchange_weak-成员函数">std::atomic::compare_exchange_weak 成员函数</a></h3>
<p>原子的比较新值和期望值，如果相等，那么存储新值并且进行原子化更新。当两值不相等，或更新未进行，那期望值会更新为新值。</p>
<p><strong>声明</strong></p>
<pre><code>bool compare_exchange_weak(
    BaseType&amp; expected,BaseType new_value,
    memory_order order = std::memory_order_seq_cst) volatile noexcept;
bool compare_exchange_weak(
    BaseType&amp; expected,BaseType new_value,
    memory_order order = std::memory_order_seq_cst) noexcept;
bool compare_exchange_weak(
    BaseType&amp; expected,BaseType new_value,
    memory_order success_order,memory_order failure_order)
    volatile noexcept;
bool compare_exchange_weak(
    BaseType&amp; expected,BaseType new_value,
    memory_order success_order,memory_order failure_order) noexcept;
</code></pre>
<p><strong>先决条件</strong>
failure_order不能是<code>std::memory_order_release</code>或<code>std::memory_order_acq_rel</code>内存序。</p>
<p><strong>效果</strong>
将存储在<em>this中的expected值与new_value值进行逐位对比，当相等时间new_value存储在</em>this中；否则，更新expected的值。</p>
<p><strong>返回</strong>
当new_value的值与*this中已经存在的值相同，就返回true；否则，返回false。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:在success_order==order和failure_order==order的情况下，三个参数的重载函数与四个参数的重载函数等价。除非，order是<code>std::memory_order_acq_rel</code>时，failure_order是<code>std::memory_order_acquire</code>，且当order是<code>std::memory_order_release</code>时，failure_order是<code>std::memory_order_relaxed</code>。</p>
<p><strong>NOTE</strong>:当返回true和success_order内存序时，是对<em>this内存地址的原子“读-改-写”操作；反之，这是对</em>this内存地址的原子加载操作(failure_order)。</p>
<h3 id="stdatomic_compare_exchange_weak-非成员函数"><a class="header" href="#stdatomic_compare_exchange_weak-非成员函数">std::atomic_compare_exchange_weak 非成员函数</a></h3>
<p>原子的比较新值和期望值，如果相等，那么存储新值并且进行原子化更新。当两值不相等，或更新未进行，那期望值会更新为新值。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak(
    volatile atomic&lt;BaseType&gt;* p,BaseType * old_value,BaseType new_value)
    noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak(
    atomic&lt;BaseType&gt;* p,BaseType * old_value,BaseType new_value) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;compare_exchange_weak(*old_value,new_value);
</code></pre>
<h3 id="stdatomic_compare_exchange_weak_explicit-非成员函数"><a class="header" href="#stdatomic_compare_exchange_weak_explicit-非成员函数">std::atomic_compare_exchange_weak_explicit 非成员函数</a></h3>
<p>原子的比较新值和期望值，如果相等，那么存储新值并且进行原子化更新。当两值不相等，或更新未进行，那期望值会更新为新值。</p>
<p><strong>声明</strong></p>
<pre><code>template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak_explicit(
    volatile atomic&lt;BaseType&gt;* p,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak_explicit(
    atomic&lt;BaseType&gt;* p,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;compare_exchange_weak(
   *old_value,new_value,success_order,failure_order);
</code></pre>
<h2 id="d39-stdatomic模板类型的特化"><a class="header" href="#d39-stdatomic模板类型的特化">D.3.9 std::atomic模板类型的特化</a></h2>
<p><code>std::atomic</code>类模板的特化类型有整型和指针类型。对于整型来说，特化模板提供原子加减，以及位域操作(主模板未提供)。对于指针类型来说，特化模板提供原子指针的运算(主模板未提供)。</p>
<p>特化模板提供如下整型：</p>
<pre><code>std::atomic&lt;bool&gt;
std::atomic&lt;char&gt;
std::atomic&lt;signed char&gt;
std::atomic&lt;unsigned char&gt;
std::atomic&lt;short&gt;
std::atomic&lt;unsigned short&gt;
std::atomic&lt;int&gt;
std::atomic&lt;unsigned&gt;
std::atomic&lt;long&gt;
std::atomic&lt;unsigned long&gt;
std::atomic&lt;long long&gt;
std::atomic&lt;unsigned long long&gt;
std::atomic&lt;wchar_t&gt;
std::atomic&lt;char16_t&gt;
std::atomic&lt;char32_t&amp;gt;
</code></pre>
<p><code>std::atomic&lt;T*&gt;</code>原子指针，可以使用以上的类型作为T。</p>
<h2 id="d310-特化stdatomicintegral-type"><a class="header" href="#d310-特化stdatomicintegral-type">D.3.10 特化std::atomic&lt;integral-type&gt;</a></h2>
<p><code>std::atomic&amp;lt;integral-type&amp;gt;</code>是为每一个基础整型提供的<code>std::atomic</code>类模板，其中提供了一套完整的整型操作。</p>
<p>下面的特化模板也适用于<code>std::atomic&lt;&gt;</code>类模板：</p>
<pre><code>std::atomic&lt;char&gt;
std::atomic&lt;signed char&gt;
std::atomic&lt;unsigned char&gt;
std::atomic&lt;short&gt;
std::atomic&lt;unsigned short&gt;
std::atomic&lt;int&gt;
std::atomic&lt;unsigned&gt;
std::atomic&lt;long&gt;
std::atomic&lt;unsigned long&gt;
std::atomic&lt;long long&gt;
std::atomic&lt;unsigned long long&gt;
std::atomic&lt;wchar_t&gt;
std::atomic&lt;char16_t&gt;
std::atomic&lt;char32_t&gt;
</code></pre>
<p>因为原子操作只能执行其中一个，所以特化模板的实例不可<code>CopyConstructible</code>(拷贝构造)和<code>CopyAssignable</code>(拷贝赋值)。</p>
<p><strong>类型定义</strong></p>
<pre><code>template&lt;&gt;
struct atomic&lt;integral-type&gt;
{
  atomic() noexcept = default;
  constexpr atomic(integral-type) noexcept;
  bool operator=(integral-type) volatile noexcept;

  atomic(const atomic&amp;) = delete;
  atomic&amp; operator=(const atomic&amp;) = delete;
  atomic&amp; operator=(const atomic&amp;) volatile = delete;

  bool is_lock_free() const volatile noexcept;
  bool is_lock_free() const noexcept;

  void store(integral-type,memory_order = memory_order_seq_cst)
      volatile noexcept;
  void store(integral-type,memory_order = memory_order_seq_cst) noexcept;
  integral-type load(memory_order = memory_order_seq_cst)
      const volatile noexcept;
  integral-type load(memory_order = memory_order_seq_cst) const noexcept;
  integral-type exchange(
      integral-type,memory_order = memory_order_seq_cst)
      volatile noexcept;
 integral-type exchange(
      integral-type,memory_order = memory_order_seq_cst) noexcept;

  bool compare_exchange_strong(
      integral-type &amp; old_value,integral-type new_value,
      memory_order order = memory_order_seq_cst) volatile noexcept;
  bool compare_exchange_strong(
      integral-type &amp; old_value,integral-type new_value,
      memory_order order = memory_order_seq_cst) noexcept;
  bool compare_exchange_strong(
      integral-type &amp; old_value,integral-type new_value,
      memory_order success_order,memory_order failure_order)
      volatile noexcept;
  bool compare_exchange_strong(
      integral-type &amp; old_value,integral-type new_value,
      memory_order success_order,memory_order failure_order) noexcept;
  bool compare_exchange_weak(
      integral-type &amp; old_value,integral-type new_value,
      memory_order order = memory_order_seq_cst) volatile noexcept;
  bool compare_exchange_weak(
      integral-type &amp; old_value,integral-type new_value,
      memory_order order = memory_order_seq_cst) noexcept;
  bool compare_exchange_weak(
      integral-type &amp; old_value,integral-type new_value,
      memory_order success_order,memory_order failure_order)
      volatile noexcept;
  bool compare_exchange_weak(
      integral-type &amp; old_value,integral-type new_value,
      memory_order success_order,memory_order failure_order) noexcept;

  operator integral-type() const volatile noexcept;
  operator integral-type() const noexcept;

  integral-type fetch_add(
      integral-type,memory_order = memory_order_seq_cst)
      volatile noexcept;
  integral-type fetch_add(
      integral-type,memory_order = memory_order_seq_cst) noexcept;
  integral-type fetch_sub(
      integral-type,memory_order = memory_order_seq_cst)
      volatile noexcept;
  integral-type fetch_sub(
      integral-type,memory_order = memory_order_seq_cst) noexcept;
  integral-type fetch_and(
      integral-type,memory_order = memory_order_seq_cst)
      volatile noexcept;
  integral-type fetch_and(
      integral-type,memory_order = memory_order_seq_cst) noexcept;
  integral-type fetch_or(
      integral-type,memory_order = memory_order_seq_cst)
      volatile noexcept;
  integral-type fetch_or(
      integral-type,memory_order = memory_order_seq_cst) noexcept;
  integral-type fetch_xor(
      integral-type,memory_order = memory_order_seq_cst)
      volatile noexcept;
  integral-type fetch_xor(
      integral-type,memory_order = memory_order_seq_cst) noexcept;

  integral-type operator++() volatile noexcept;
  integral-type operator++() noexcept;
  integral-type operator++(int) volatile noexcept;
  integral-type operator++(int) noexcept;
  integral-type operator--() volatile noexcept;
  integral-type operator--() noexcept;
  integral-type operator--(int) volatile noexcept;
  integral-type operator--(int) noexcept;
  integral-type operator+=(integral-type) volatile noexcept;
  integral-type operator+=(integral-type) noexcept;
  integral-type operator-=(integral-type) volatile noexcept;
  integral-type operator-=(integral-type) noexcept;
  integral-type operator&amp;=(integral-type) volatile noexcept;
  integral-type operator&amp;=(integral-type) noexcept;
  integral-type operator|=(integral-type) volatile noexcept;
  integral-type operator|=(integral-type) noexcept;
  integral-type operator^=(integral-type) volatile noexcept;
  integral-type operator^=(integral-type) noexcept;
};

bool atomic_is_lock_free(volatile const atomic&lt;integral-type&gt;*) noexcept;
bool atomic_is_lock_free(const atomic&lt;integral-type&gt;*) noexcept;
void atomic_init(volatile atomic&lt;integral-type&gt;*,integral-type) noexcept;
void atomic_init(atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_exchange(
    volatile atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_exchange(
    atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_exchange_explicit(
    volatile atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_exchange_explicit(
    atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
void atomic_store(volatile atomic&lt;integral-type&gt;*,integral-type) noexcept;
void atomic_store(atomic&lt;integral-type&gt;*,integral-type) noexcept;
void atomic_store_explicit(
    volatile atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
void atomic_store_explicit(
    atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_load(volatile const atomic&lt;integral-type&gt;*) noexcept;
integral-type atomic_load(const atomic&lt;integral-type&gt;*) noexcept;
integral-type atomic_load_explicit(
    volatile const atomic&lt;integral-type&gt;*,memory_order) noexcept;
integral-type atomic_load_explicit(
    const atomic&lt;integral-type&gt;*,memory_order) noexcept;
bool atomic_compare_exchange_strong(
    volatile atomic&lt;integral-type&gt;*,
    integral-type * old_value,integral-type new_value) noexcept;
bool atomic_compare_exchange_strong(
    atomic&lt;integral-type&gt;*,
    integral-type * old_value,integral-type new_value) noexcept;
bool atomic_compare_exchange_strong_explicit(
    volatile atomic&lt;integral-type&gt;*,
    integral-type * old_value,integral-type new_value,
    memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_strong_explicit(
    atomic&lt;integral-type&gt;*,
    integral-type * old_value,integral-type new_value,
    memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_weak(
    volatile atomic&lt;integral-type&gt;*,
    integral-type * old_value,integral-type new_value) noexcept;
bool atomic_compare_exchange_weak(
    atomic&lt;integral-type&gt;*,
    integral-type * old_value,integral-type new_value) noexcept;
bool atomic_compare_exchange_weak_explicit(
    volatile atomic&lt;integral-type&gt;*,
    integral-type * old_value,integral-type new_value,
    memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_weak_explicit(
    atomic&lt;integral-type&gt;*,
    integral-type * old_value,integral-type new_value,
    memory_order success_order,memory_order failure_order) noexcept;

integral-type atomic_fetch_add(
    volatile atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_add(
    atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_add_explicit(
    volatile atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_fetch_add_explicit(
    atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_fetch_sub(
    volatile atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_sub(
    atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_sub_explicit(
    volatile atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_fetch_sub_explicit(
    atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_fetch_and(
    volatile atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_and(
    atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_and_explicit(
    volatile atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_fetch_and_explicit(
    atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_fetch_or(
    volatile atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_or(
    atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_or_explicit(
    volatile atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_fetch_or_explicit(
    atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_fetch_xor(
    volatile atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_xor(
    atomic&lt;integral-type&gt;*,integral-type) noexcept;
integral-type atomic_fetch_xor_explicit(
    volatile atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
integral-type atomic_fetch_xor_explicit(
    atomic&lt;integral-type&gt;*,integral-type, memory_order) noexcept;
</code></pre>
<p>这些操作在主模板中也有提供(见D.3.8)。</p>
<h3 id="stdatomicintegral-typefetch_add-成员函数"><a class="header" href="#stdatomicintegral-typefetch_add-成员函数">std::atomic&lt;integral-type&gt;::fetch_add 成员函数</a></h3>
<p>原子的加载一个值，然后使用与提供i相加的结果，替换掉原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type fetch_add(
    integral-type i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
integral-type fetch_add(
    integral-type i,memory_order order = memory_order_seq_cst) noexcept;
</code></pre>
<p><strong>效果</strong>
原子的查询<em>this中的值，将old-value+i的和存回</em>this。</p>
<p><strong>返回</strong>
返回*this之前存储的值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:对于*this的内存地址来说，这是一个“读-改-写”操作。</p>
<h3 id="stdatomic_fetch_add-非成员函数"><a class="header" href="#stdatomic_fetch_add-非成员函数">std::atomic_fetch_add 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值相加，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_add(
    volatile atomic&lt;integral-type&gt;* p, integral-type i) noexcept;
integral-type atomic_fetch_add(
    atomic&lt;integral-type&gt;* p, integral-type i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_add(i);
</code></pre>
<h3 id="stdatomic_fetch_add_explicit-非成员函数"><a class="header" href="#stdatomic_fetch_add_explicit-非成员函数">std::atomic_fetch_add_explicit 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值相加，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_add_explicit(
    volatile atomic&lt;integral-type&gt;* p, integral-type i,
    memory_order order) noexcept;
integral-type atomic_fetch_add_explicit(
    atomic&lt;integral-type&gt;* p, integral-type i, memory_order order)
    noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_add(i,order);
</code></pre>
<h3 id="stdatomicintegral-typefetch_sub-成员函数"><a class="header" href="#stdatomicintegral-typefetch_sub-成员函数">std::atomic&lt;integral-type&gt;::fetch_sub 成员函数</a></h3>
<p>原子的加载一个值，然后使用与提供i相减的结果，替换掉原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type fetch_sub(
    integral-type i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
integral-type fetch_sub(
    integral-type i,memory_order order = memory_order_seq_cst) noexcept;
</code></pre>
<p><strong>效果</strong>
原子的查询<em>this中的值，将old-value-i的和存回</em>this。</p>
<p><strong>返回</strong>
返回*this之前存储的值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:对于*this的内存地址来说，这是一个“读-改-写”操作。</p>
<h3 id="stdatomic_fetch_sub-非成员函数"><a class="header" href="#stdatomic_fetch_sub-非成员函数">std::atomic_fetch_sub 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值相减，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_sub(
    volatile atomic&lt;integral-type&gt;* p, integral-type i) noexcept;
integral-type atomic_fetch_sub(
    atomic&lt;integral-type&gt;* p, integral-type i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_sub(i);
</code></pre>
<h3 id="stdatomic_fetch_sub_explicit-非成员函数"><a class="header" href="#stdatomic_fetch_sub_explicit-非成员函数">std::atomic_fetch_sub_explicit 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值相减，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_sub_explicit(
    volatile atomic&lt;integral-type&gt;* p, integral-type i,
    memory_order order) noexcept;
integral-type atomic_fetch_sub_explicit(
    atomic&lt;integral-type&gt;* p, integral-type i, memory_order order)
    noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_sub(i,order);
</code></pre>
<h3 id="stdatomicintegral-typefetch_and-成员函数"><a class="header" href="#stdatomicintegral-typefetch_and-成员函数">std::atomic&lt;integral-type&gt;::fetch_and 成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位与操作后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type fetch_and(
    integral-type i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
integral-type fetch_and(
    integral-type i,memory_order order = memory_order_seq_cst) noexcept;
</code></pre>
<p><strong>效果</strong>
原子的查询<em>this中的值，将old-value&amp;i的和存回</em>this。</p>
<p><strong>返回</strong>
返回*this之前存储的值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:对于*this的内存地址来说，这是一个“读-改-写”操作。</p>
<h3 id="stdatomic_fetch_and-非成员函数"><a class="header" href="#stdatomic_fetch_and-非成员函数">std::atomic_fetch_and 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位与操作后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_and(
    volatile atomic&lt;integral-type&gt;* p, integral-type i) noexcept;
integral-type atomic_fetch_and(
    atomic&lt;integral-type&gt;* p, integral-type i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_and(i);
</code></pre>
<h3 id="stdatomic_fetch_and_explicit-非成员函数"><a class="header" href="#stdatomic_fetch_and_explicit-非成员函数">std::atomic_fetch_and_explicit 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位与操作后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_and_explicit(
    volatile atomic&lt;integral-type&gt;* p, integral-type i,
    memory_order order) noexcept;
integral-type atomic_fetch_and_explicit(
    atomic&lt;integral-type&gt;* p, integral-type i, memory_order order)
    noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_and(i,order);
</code></pre>
<h3 id="stdatomicintegral-typefetch_or-成员函数"><a class="header" href="#stdatomicintegral-typefetch_or-成员函数">std::atomic&lt;integral-type&gt;::fetch_or 成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位或操作后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type fetch_or(
    integral-type i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
integral-type fetch_or(
    integral-type i,memory_order order = memory_order_seq_cst) noexcept;
</code></pre>
<p><strong>效果</strong>
原子的查询<em>this中的值，将old-value|i的和存回</em>this。</p>
<p><strong>返回</strong>
返回*this之前存储的值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:对于*this的内存地址来说，这是一个“读-改-写”操作。</p>
<h3 id="stdatomic_fetch_or-非成员函数"><a class="header" href="#stdatomic_fetch_or-非成员函数">std::atomic_fetch_or 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位或操作后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_or(
    volatile atomic&lt;integral-type&gt;* p, integral-type i) noexcept;
integral-type atomic_fetch_or(
    atomic&lt;integral-type&gt;* p, integral-type i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_or(i);
</code></pre>
<h3 id="stdatomic_fetch_or_explicit-非成员函数"><a class="header" href="#stdatomic_fetch_or_explicit-非成员函数">std::atomic_fetch_or_explicit 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位或操作后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_or_explicit(
    volatile atomic&lt;integral-type&gt;* p, integral-type i,
    memory_order order) noexcept;
integral-type atomic_fetch_or_explicit(
    atomic&lt;integral-type&gt;* p, integral-type i, memory_order order)
    noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_or(i,order);
</code></pre>
<h3 id="stdatomicintegral-typefetch_xor-成员函数"><a class="header" href="#stdatomicintegral-typefetch_xor-成员函数">std::atomic&lt;integral-type&gt;::fetch_xor 成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位亦或操作后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type fetch_xor(
    integral-type i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
integral-type fetch_xor(
    integral-type i,memory_order order = memory_order_seq_cst) noexcept;
</code></pre>
<p><strong>效果</strong>
原子的查询<em>this中的值，将old-value^i的和存回</em>this。</p>
<p><strong>返回</strong>
返回*this之前存储的值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:对于*this的内存地址来说，这是一个“读-改-写”操作。</p>
<h3 id="stdatomic_fetch_xor-非成员函数"><a class="header" href="#stdatomic_fetch_xor-非成员函数">std::atomic_fetch_xor 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位异或操作后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_xor_explicit(
    volatile atomic&lt;integral-type&gt;* p, integral-type i,
    memory_order order) noexcept;
integral-type atomic_fetch_xor_explicit(
    atomic&lt;integral-type&gt;* p, integral-type i, memory_order order)
    noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_xor(i,order);
</code></pre>
<h3 id="stdatomic_fetch_xor_explicit-非成员函数"><a class="header" href="#stdatomic_fetch_xor_explicit-非成员函数">std::atomic_fetch_xor_explicit 非成员函数</a></h3>
<p>从<code>atomic&lt;integral-type&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位异或操作后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type atomic_fetch_xor_explicit(
    volatile atomic&lt;integral-type&gt;* p, integral-type i,
    memory_order order) noexcept;
integral-type atomic_fetch_xor_explicit(
    atomic&lt;integral-type&gt;* p, integral-type i, memory_order order)
    noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_xor(i,order);
</code></pre>
<h3 id="stdatomicintegral-typeoperator-前置递增操作"><a class="header" href="#stdatomicintegral-typeoperator-前置递增操作">std::atomic&lt;integral-type&gt;::operator++ 前置递增操作</a></h3>
<p>原子的将*this中存储的值加1，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type operator++() volatile noexcept;
integral-type operator++() noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_add(1) + 1;
</code></pre>
<h3 id="stdatomicintegral-typeoperator-后置递增操作"><a class="header" href="#stdatomicintegral-typeoperator-后置递增操作">std::atomic&lt;integral-type&gt;::operator++ 后置递增操作</a></h3>
<p>原子的将*this中存储的值加1，并返回旧值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type operator++() volatile noexcept;
integral-type operator++() noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_add(1);
</code></pre>
<h3 id="stdatomicintegral-typeoperator---前置递减操作"><a class="header" href="#stdatomicintegral-typeoperator---前置递减操作">std::atomic&lt;integral-type&gt;::operator-- 前置递减操作</a></h3>
<p>原子的将*this中存储的值减1，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type operator--() volatile noexcept;
integral-type operator--() noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_add(1) - 1;
</code></pre>
<h3 id="stdatomicintegral-typeoperator---后置递减操作"><a class="header" href="#stdatomicintegral-typeoperator---后置递减操作">std::atomic&lt;integral-type&gt;::operator-- 后置递减操作</a></h3>
<p>原子的将*this中存储的值减1，并返回旧值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type operator--() volatile noexcept;
integral-type operator--() noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_add(1);
</code></pre>
<h3 id="stdatomicintegral-typeoperator-复合赋值操作"><a class="header" href="#stdatomicintegral-typeoperator-复合赋值操作">std::atomic&lt;integral-type&gt;::operator+= 复合赋值操作</a></h3>
<p>原子的将给定值与*this中的值相加，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type operator+=(integral-type i) volatile noexcept;
integral-type operator+=(integral-type i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_add(i) + i;
</code></pre>
<h3 id="stdatomicintegral-typeoperator--复合赋值操作"><a class="header" href="#stdatomicintegral-typeoperator--复合赋值操作">std::atomic&lt;integral-type&gt;::operator-= 复合赋值操作</a></h3>
<p>原子的将给定值与*this中的值相减，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type operator-=(integral-type i) volatile noexcept;
integral-type operator-=(integral-type i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_sub(i,std::memory_order_seq_cst) – i;
</code></pre>
<h3 id="stdatomicintegral-typeoperator-复合赋值操作-1"><a class="header" href="#stdatomicintegral-typeoperator-复合赋值操作-1">std::atomic&lt;integral-type&gt;::operator&amp;= 复合赋值操作</a></h3>
<p>原子的将给定值与*this中的值相与，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type operator&amp;=(integral-type i) volatile noexcept;
integral-type operator&amp;=(integral-type i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_and(i) &amp; i;
</code></pre>
<h3 id="stdatomicintegral-typeoperator-复合赋值操作-2"><a class="header" href="#stdatomicintegral-typeoperator-复合赋值操作-2">std::atomic&lt;integral-type&gt;::operator|= 复合赋值操作</a></h3>
<p>原子的将给定值与*this中的值相或，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type operator|=(integral-type i) volatile noexcept;
integral-type operator|=(integral-type i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_or(i,std::memory_order_seq_cst) | i;
</code></pre>
<h3 id="stdatomicintegral-typeoperator-复合赋值操作-3"><a class="header" href="#stdatomicintegral-typeoperator-复合赋值操作-3">std::atomic&lt;integral-type&gt;::operator^= 复合赋值操作</a></h3>
<p>原子的将给定值与*this中的值相亦或，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>integral-type operator^=(integral-type i) volatile noexcept;
integral-type operator^=(integral-type i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_xor(i,std::memory_order_seq_cst) ^ i;
</code></pre>
<h3 id="stdatomict-局部特化"><a class="header" href="#stdatomict-局部特化">std::atomic&lt;T*&gt; 局部特化</a></h3>
<p><code>std::atomic&lt;T*&gt;</code>为<code>std::atomic</code>特化了指针类型原子变量，并提供了一系列相关操作。</p>
<p><code>std::atomic&lt;T*&gt;</code>是CopyConstructible(拷贝构造)和CopyAssignable(拷贝赋值)的，因为操作是原子的，在同一时间只能执行一个操作。</p>
<p><strong>类型定义</strong></p>
<pre><code>template&lt;typename T&gt;
struct atomic&lt;T*&gt;
{
  atomic() noexcept = default;
  constexpr atomic(T*) noexcept;
  bool operator=(T*) volatile;
  bool operator=(T*);

  atomic(const atomic&amp;) = delete;
  atomic&amp; operator=(const atomic&amp;) = delete;
  atomic&amp; operator=(const atomic&amp;) volatile = delete;

  bool is_lock_free() const volatile noexcept;
  bool is_lock_free() const noexcept;
  void store(T*,memory_order = memory_order_seq_cst) volatile noexcept;
  void store(T*,memory_order = memory_order_seq_cst) noexcept;
  T* load(memory_order = memory_order_seq_cst) const volatile noexcept;
  T* load(memory_order = memory_order_seq_cst) const noexcept;
  T* exchange(T*,memory_order = memory_order_seq_cst) volatile noexcept;
  T* exchange(T*,memory_order = memory_order_seq_cst) noexcept;

  bool compare_exchange_strong(
      T* &amp; old_value, T* new_value,
      memory_order order = memory_order_seq_cst) volatile noexcept;
  bool compare_exchange_strong(
      T* &amp; old_value, T* new_value,
      memory_order order = memory_order_seq_cst) noexcept;
  bool compare_exchange_strong(
      T* &amp; old_value, T* new_value,
      memory_order success_order,memory_order failure_order)  
      volatile noexcept;
  bool compare_exchange_strong(
      T* &amp; old_value, T* new_value,
      memory_order success_order,memory_order failure_order) noexcept;
  bool compare_exchange_weak(
      T* &amp; old_value, T* new_value,
      memory_order order = memory_order_seq_cst) volatile noexcept;
  bool compare_exchange_weak(
      T* &amp; old_value, T* new_value,
      memory_order order = memory_order_seq_cst) noexcept;
  bool compare_exchange_weak(
      T* &amp; old_value, T* new_value,
      memory_order success_order,memory_order failure_order)
      volatile noexcept;
  bool compare_exchange_weak(
      T* &amp; old_value, T* new_value,
      memory_order success_order,memory_order failure_order) noexcept;

  operator T*() const volatile noexcept;
  operator T*() const noexcept;

  T* fetch_add(
      ptrdiff_t,memory_order = memory_order_seq_cst) volatile noexcept;
  T* fetch_add(
      ptrdiff_t,memory_order = memory_order_seq_cst) noexcept;
  T* fetch_sub(
      ptrdiff_t,memory_order = memory_order_seq_cst) volatile noexcept;
  T* fetch_sub(
      ptrdiff_t,memory_order = memory_order_seq_cst) noexcept;

  T* operator++() volatile noexcept;
  T* operator++() noexcept;
  T* operator++(int) volatile noexcept;
  T* operator++(int) noexcept;
  T* operator--() volatile noexcept;
  T* operator--() noexcept;
  T* operator--(int) volatile noexcept;
  T* operator--(int) noexcept;

  T* operator+=(ptrdiff_t) volatile noexcept;
  T* operator+=(ptrdiff_t) noexcept;
  T* operator-=(ptrdiff_t) volatile noexcept;
  T* operator-=(ptrdiff_t) noexcept;
};

bool atomic_is_lock_free(volatile const atomic&lt;T*&gt;*) noexcept;
bool atomic_is_lock_free(const atomic&lt;T*&gt;*) noexcept;
void atomic_init(volatile atomic&lt;T*&gt;*, T*) noexcept;
void atomic_init(atomic&lt;T*&gt;*, T*) noexcept;
T* atomic_exchange(volatile atomic&lt;T*&gt;*, T*) noexcept;
T* atomic_exchange(atomic&lt;T*&gt;*, T*) noexcept;
T* atomic_exchange_explicit(volatile atomic&lt;T*&gt;*, T*, memory_order)
  noexcept;
T* atomic_exchange_explicit(atomic&lt;T*&gt;*, T*, memory_order) noexcept;
void atomic_store(volatile atomic&lt;T*&gt;*, T*) noexcept;
void atomic_store(atomic&lt;T*&gt;*, T*) noexcept;
void atomic_store_explicit(volatile atomic&lt;T*&gt;*, T*, memory_order)
  noexcept;
void atomic_store_explicit(atomic&lt;T*&gt;*, T*, memory_order) noexcept;
T* atomic_load(volatile const atomic&lt;T*&gt;*) noexcept;
T* atomic_load(const atomic&lt;T*&gt;*) noexcept;
T* atomic_load_explicit(volatile const atomic&lt;T*&gt;*, memory_order) noexcept;
T* atomic_load_explicit(const atomic&lt;T*&gt;*, memory_order) noexcept;
bool atomic_compare_exchange_strong(
  volatile atomic&lt;T*&gt;*,T* * old_value,T* new_value) noexcept;
bool atomic_compare_exchange_strong(
  volatile atomic&lt;T*&gt;*,T* * old_value,T* new_value) noexcept;
bool atomic_compare_exchange_strong_explicit(
  atomic&lt;T*&gt;*,T* * old_value,T* new_value,
  memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_strong_explicit(
  atomic&lt;T*&gt;*,T* * old_value,T* new_value,
  memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_weak(
  volatile atomic&lt;T*&gt;*,T* * old_value,T* new_value) noexcept;
bool atomic_compare_exchange_weak(
  atomic&lt;T*&gt;*,T* * old_value,T* new_value) noexcept;
bool atomic_compare_exchange_weak_explicit(
  volatile atomic&lt;T*&gt;*,T* * old_value, T* new_value,
  memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_weak_explicit(
  atomic&lt;T*&gt;*,T* * old_value, T* new_value,
  memory_order success_order,memory_order failure_order) noexcept;

T* atomic_fetch_add(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
T* atomic_fetch_add(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
T* atomic_fetch_add_explicit(
  volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
T* atomic_fetch_add_explicit(
  atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
T* atomic_fetch_sub(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
T* atomic_fetch_sub(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
T* atomic_fetch_sub_explicit(
  volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
T* atomic_fetch_sub_explicit(
  atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
</code></pre>
<p>在主模板中也提供了一些相同的操作(可见11.3.8节)。</p>
<h3 id="stdatomictfetch_add-成员函数"><a class="header" href="#stdatomictfetch_add-成员函数">std::atomic&lt;T*&gt;::fetch_add 成员函数</a></h3>
<p>原子的加载一个值，然后使用与提供i相加(使用标准指针运算规则)的结果，替换掉原值。</p>
<p><strong>声明</strong></p>
<pre><code>T* fetch_add(
    ptrdiff_t i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
T* fetch_add(
    ptrdiff_t i,memory_order order = memory_order_seq_cst) noexcept;
</code></pre>
<p><strong>效果</strong>
原子的查询<em>this中的值，将old-value+i的和存回</em>this。</p>
<p><strong>返回</strong>
返回*this之前存储的值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:对于*this的内存地址来说，这是一个“读-改-写”操作。</p>
<h3 id="stdatomic_fetch_add-非成员函数-1"><a class="header" href="#stdatomic_fetch_add-非成员函数-1">std::atomic_fetch_add 非成员函数</a></h3>
<p>从<code>atomic&lt;T*&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位相加操作(使用标准指针运算规则)后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>T* atomic_fetch_add(volatile atomic&lt;T*&gt;* p, ptrdiff_t i) noexcept;
T* atomic_fetch_add(atomic&lt;T*&gt;* p, ptrdiff_t i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_add(i);
</code></pre>
<h3 id="stdatomic_fetch_add_explicit-非成员函数-1"><a class="header" href="#stdatomic_fetch_add_explicit-非成员函数-1">std::atomic_fetch_add_explicit 非成员函数</a></h3>
<p>从<code>atomic&lt;T*&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位相加操作(使用标准指针运算规则)后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>T* atomic_fetch_add_explicit(
     volatile atomic&lt;T*&gt;* p, ptrdiff_t i,memory_order order) noexcept;
T* atomic_fetch_add_explicit(
     atomic&lt;T*&gt;* p, ptrdiff_t i, memory_order order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_add(i,order);
</code></pre>
<h3 id="stdatomictfetch_sub-成员函数"><a class="header" href="#stdatomictfetch_sub-成员函数">std::atomic&lt;T*&gt;::fetch_sub 成员函数</a></h3>
<p>原子的加载一个值，然后使用与提供i相减(使用标准指针运算规则)的结果，替换掉原值。</p>
<p><strong>声明</strong></p>
<pre><code>T* fetch_sub(
    ptrdiff_t i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
T* fetch_sub(
    ptrdiff_t i,memory_order order = memory_order_seq_cst) noexcept;
</code></pre>
<p><strong>效果</strong>
原子的查询<em>this中的值，将old-value-i的和存回</em>this。</p>
<p><strong>返回</strong>
返回*this之前存储的值。</p>
<p><strong>抛出</strong>
无</p>
<p><strong>NOTE</strong>:对于*this的内存地址来说，这是一个“读-改-写”操作。</p>
<h3 id="stdatomic_fetch_sub-非成员函数-1"><a class="header" href="#stdatomic_fetch_sub-非成员函数-1">std::atomic_fetch_sub 非成员函数</a></h3>
<p>从<code>atomic&lt;T*&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位相减操作(使用标准指针运算规则)后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>T* atomic_fetch_sub(volatile atomic&lt;T*&gt;* p, ptrdiff_t i) noexcept;
T* atomic_fetch_sub(atomic&lt;T*&gt;* p, ptrdiff_t i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_sub(i);
</code></pre>
<h3 id="stdatomic_fetch_sub_explicit-非成员函数-1"><a class="header" href="#stdatomic_fetch_sub_explicit-非成员函数-1">std::atomic_fetch_sub_explicit 非成员函数</a></h3>
<p>从<code>atomic&lt;T*&gt;</code>实例中原子的读取一个值，并且将其与给定i值进行位相减操作(使用标准指针运算规则)后，替换原值。</p>
<p><strong>声明</strong></p>
<pre><code>T* atomic_fetch_sub_explicit(
     volatile atomic&lt;T*&gt;* p, ptrdiff_t i,memory_order order) noexcept;
T* atomic_fetch_sub_explicit(
     atomic&lt;T*&gt;* p, ptrdiff_t i, memory_order order) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return p-&gt;fetch_sub(i,order);
</code></pre>
<h3 id="stdatomictoperator-前置递增操作"><a class="header" href="#stdatomictoperator-前置递增操作">std::atomic&lt;T*&gt;::operator++ 前置递增操作</a></h3>
<p>原子的将*this中存储的值加1(使用标准指针运算规则)，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>T* operator++() volatile noexcept;
T* operator++() noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_add(1) + 1;
</code></pre>
<h3 id="stdatomictoperator-后置递增操作"><a class="header" href="#stdatomictoperator-后置递增操作">std::atomic&lt;T*&gt;::operator++ 后置递增操作</a></h3>
<p>原子的将*this中存储的值加1(使用标准指针运算规则)，并返回旧值。</p>
<p><strong>声明</strong></p>
<pre><code>T* operator++() volatile noexcept;
T* operator++() noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_add(1);
</code></pre>
<h3 id="stdatomictoperator---前置递减操作"><a class="header" href="#stdatomictoperator---前置递减操作">std::atomic&lt;T*&gt;::operator-- 前置递减操作</a></h3>
<p>原子的将*this中存储的值减1(使用标准指针运算规则)，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>T* operator--() volatile noexcept;
T* operator--() noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_sub(1) - 1;
</code></pre>
<h3 id="stdatomictoperator---后置递减操作"><a class="header" href="#stdatomictoperator---后置递减操作">std::atomic&lt;T*&gt;::operator-- 后置递减操作</a></h3>
<p>原子的将*this中存储的值减1(使用标准指针运算规则)，并返回旧值。</p>
<p><strong>声明</strong></p>
<pre><code>T* operator--() volatile noexcept;
T* operator--() noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_sub(1);
</code></pre>
<h3 id="stdatomictoperator-复合赋值操作"><a class="header" href="#stdatomictoperator-复合赋值操作">std::atomic&lt;T*&gt;::operator+= 复合赋值操作</a></h3>
<p>原子的将*this中存储的值与给定值相加(使用标准指针运算规则)，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>T* operator+=(ptrdiff_t i) volatile noexcept;
T* operator+=(ptrdiff_t i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_add(i) + i;
</code></pre>
<h3 id="stdatomictoperator--复合赋值操作"><a class="header" href="#stdatomictoperator--复合赋值操作">std::atomic&lt;T*&gt;::operator-= 复合赋值操作</a></h3>
<p>原子的将*this中存储的值与给定值相减(使用标准指针运算规则)，并返回新值。</p>
<p><strong>声明</strong></p>
<pre><code>T* operator+=(ptrdiff_t i) volatile noexcept;
T* operator+=(ptrdiff_t i) noexcept;
</code></pre>
<p><strong>效果</strong></p>
<pre><code>return this-&gt;fetch_add(i) - i;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../content/appendix_D/D.2-chinese.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../content/appendix_D/D.4-chinese.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../content/appendix_D/D.2-chinese.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../content/appendix_D/D.4-chinese.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
